   1              		.cpu arm926ej-s
   2              		.fpu softvfp
   3              		.eabi_attribute 20, 1
   4              		.eabi_attribute 21, 1
   5              		.eabi_attribute 23, 3
   6              		.eabi_attribute 24, 1
   7              		.eabi_attribute 25, 1
   8              		.eabi_attribute 26, 1
   9              		.eabi_attribute 30, 6
  10              		.eabi_attribute 18, 4
  11              		.file	"cyfxtx.c"
  19              	.Ltext0:
  20              		.cfi_sections	.debug_frame
  21              		.global	glMemPoolInit
  22              		.bss
  23              		.align	2
  26              	glMemPoolInit:
  27 0000 00000000 		.space	4
  28              		.comm	glMemBytePool,52,4
  29              		.global	glBufferManager
  30              		.align	2
  33              	glBufferManager:
  34 0004 00000000 		.space	76
  34      00000000 
  34      00000000 
  34      00000000 
  34      00000000 
  35              		.text
  36              		.align	2
  37              		.global	CyU3PUndefinedHandler
  39              	CyU3PUndefinedHandler:
  40              	.LFB0:
  41              		.file 1 "../cyfxtx.c"
   1:../cyfxtx.c   **** /*
   2:../cyfxtx.c   ****  ## Cypress USB 3.0 Platform source file (cyfxtx.c)
   3:../cyfxtx.c   ****  ## ===========================
   4:../cyfxtx.c   ****  ##
   5:../cyfxtx.c   ****  ##  Copyright Cypress Semiconductor Corporation, 2010-2011,
   6:../cyfxtx.c   ****  ##  All Rights Reserved
   7:../cyfxtx.c   ****  ##  UNPUBLISHED, LICENSED SOFTWARE.
   8:../cyfxtx.c   ****  ##
   9:../cyfxtx.c   ****  ##  CONFIDENTIAL AND PROPRIETARY INFORMATION
  10:../cyfxtx.c   ****  ##  WHICH IS THE PROPERTY OF CYPRESS.
  11:../cyfxtx.c   ****  ##
  12:../cyfxtx.c   ****  ##  Use of this file is governed
  13:../cyfxtx.c   ****  ##  by the license agreement included in the file
  14:../cyfxtx.c   ****  ##
  15:../cyfxtx.c   ****  ##     <install>/license/license.txt
  16:../cyfxtx.c   ****  ##
  17:../cyfxtx.c   ****  ##  where <install> is the Cypress software
  18:../cyfxtx.c   ****  ##  installation root directory path.
  19:../cyfxtx.c   ****  ##
  20:../cyfxtx.c   ****  ## ===========================
  21:../cyfxtx.c   **** */
  22:../cyfxtx.c   **** 
  23:../cyfxtx.c   **** /* This file defines the porting requied for the ThreadX RTOS.
  24:../cyfxtx.c   ****  * This file shall be provided in source form and must be compiled
  25:../cyfxtx.c   ****  * with the application source code
  26:../cyfxtx.c   ****  */
  27:../cyfxtx.c   **** 
  28:../cyfxtx.c   **** #include <cyu3os.h>
  29:../cyfxtx.c   **** #include <cyu3error.h>
  30:../cyfxtx.c   **** 
  31:../cyfxtx.c   **** #ifdef CYMEM_256K
  32:../cyfxtx.c   **** 
  33:../cyfxtx.c   **** /*
  34:../cyfxtx.c   ****    A reduced memory map is used with the CYUSB3011/CYUSB3012 devices:
  35:../cyfxtx.c   **** 
  36:../cyfxtx.c   ****    Descriptor area    Base: 0x40000000 Size: 12  KB
  37:../cyfxtx.c   ****    Code area          Base: 0x40003000 Size: 128 KB
  38:../cyfxtx.c   ****    Data area          Base: 0x40023000 Size: 24  KB
  39:../cyfxtx.c   ****    Driver heap        Base: 0x40029000 Size: 28  KB
  40:../cyfxtx.c   ****    Buffer area        Base: 0x40030000 Size: 32  KB
  41:../cyfxtx.c   ****    2-stage boot area  Base: 0x40038000 Size: 32  KB
  42:../cyfxtx.c   ****  */
  43:../cyfxtx.c   **** 
  44:../cyfxtx.c   **** /*
  45:../cyfxtx.c   ****    The following definitions specify the start address and length of the Driver heap
  46:../cyfxtx.c   ****    area which is used by the application code as well as the drivers to allocate thread
  47:../cyfxtx.c   ****    stacks and other internal data structures.
  48:../cyfxtx.c   ****  */
  49:../cyfxtx.c   **** #define CY_U3P_MEM_HEAP_BASE         ((uint8_t *)0x40029000)
  50:../cyfxtx.c   **** #define CY_U3P_MEM_HEAP_SIZE         (0x7000)
  51:../cyfxtx.c   **** 
  52:../cyfxtx.c   **** /*
  53:../cyfxtx.c   ****    The last 32 KB of RAM is reserved for 2-stage boot operation. This value can be
  54:../cyfxtx.c   ****    changed to 0x40040000 if 2-stage boot is not used by the application.
  55:../cyfxtx.c   ****  */
  56:../cyfxtx.c   **** #define CY_U3P_SYS_MEM_TOP           (0x40038000)
  57:../cyfxtx.c   **** 
  58:../cyfxtx.c   **** #else /* 512 KB RAM is available. */
  59:../cyfxtx.c   **** 
  60:../cyfxtx.c   **** /*
  61:../cyfxtx.c   ****    The default application memory map for FX3 firmware is as follows:
  62:../cyfxtx.c   **** 
  63:../cyfxtx.c   ****    Descriptor area    Base: 0x40000000 Size: 12  KB
  64:../cyfxtx.c   ****    Code area          Base: 0x40003000 Size: 180 KB
  65:../cyfxtx.c   ****    Data area          Base: 0x40030000 Size: 32  KB
  66:../cyfxtx.c   ****    Driver heap        Base: 0x40038000 Size: 32  KB
  67:../cyfxtx.c   ****    Buffer area        Base: 0x40040000 Size: 224 KB
  68:../cyfxtx.c   ****    2-stage boot area  Base: 0x40078000 Size: 32  KB
  69:../cyfxtx.c   ****  */
  70:../cyfxtx.c   **** 
  71:../cyfxtx.c   **** /*
  72:../cyfxtx.c   ****    The following definitions specify the start address and length of the Driver heap
  73:../cyfxtx.c   ****    area which is used by the application code as well as the drivers to allocate thread
  74:../cyfxtx.c   ****    stacks and other internal data structures.
  75:../cyfxtx.c   ****  */
  76:../cyfxtx.c   **** #define CY_U3P_MEM_HEAP_BASE         ((uint8_t *)0x40038000)
  77:../cyfxtx.c   **** #define CY_U3P_MEM_HEAP_SIZE         (0x8000)
  78:../cyfxtx.c   **** 
  79:../cyfxtx.c   **** /*
  80:../cyfxtx.c   ****    The last 32 KB of RAM is reserved for 2-stage boot operation. This value can be
  81:../cyfxtx.c   ****    changed to 0x40080000 if 2-stage boot is not used by the application.
  82:../cyfxtx.c   ****  */
  83:../cyfxtx.c   **** #define CY_U3P_SYS_MEM_TOP           (0x40078000)
  84:../cyfxtx.c   **** 
  85:../cyfxtx.c   **** #endif
  86:../cyfxtx.c   **** 
  87:../cyfxtx.c   **** /*
  88:../cyfxtx.c   ****    The buffer heap is used to obtain data buffers for DMA transfers in or out of
  89:../cyfxtx.c   ****    the FX3 device. The reference implementation of the buffer allocator makes use
  90:../cyfxtx.c   ****    of a reserved area in the SYSTEM RAM and ensures that all allocated DMA buffers
  91:../cyfxtx.c   ****    are aligned to cache lines.
  92:../cyfxtx.c   ****  */
  93:../cyfxtx.c   **** #define CY_U3P_BUFFER_HEAP_BASE      (((uint32_t)(CY_U3P_MEM_HEAP_BASE) + (CY_U3P_MEM_HEAP_SIZE)))
  94:../cyfxtx.c   **** #define CY_U3P_BUFFER_HEAP_SIZE      ((CY_U3P_SYS_MEM_TOP) - (CY_U3P_BUFFER_HEAP_BASE))
  95:../cyfxtx.c   **** 
  96:../cyfxtx.c   **** #define CY_U3P_BUFFER_ALLOC_TIMEOUT  (10)
  97:../cyfxtx.c   **** #define CY_U3P_MEM_ALLOC_TIMEOUT     (10)
  98:../cyfxtx.c   **** 
  99:../cyfxtx.c   **** #define CY_U3P_MAX(a,b)                 (((a) > (b)) ? (a) : (b))
 100:../cyfxtx.c   **** #define CY_U3P_MIN(a,b)                 (((a) < (b)) ? (a) : (b))
 101:../cyfxtx.c   **** 
 102:../cyfxtx.c   **** CyBool_t         glMemPoolInit = CyFalse;
 103:../cyfxtx.c   **** CyU3PBytePool    glMemBytePool;
 104:../cyfxtx.c   **** CyU3PDmaBufMgr_t glBufferManager = {{0}, 0, 0, 0, 0, 0};
 105:../cyfxtx.c   **** 
 106:../cyfxtx.c   **** /* These functions are exception handlers. These are default
 107:../cyfxtx.c   ****  * implementations and the application firmware can have a
 108:../cyfxtx.c   ****  * re-implementation. All these exceptions are not currently
 109:../cyfxtx.c   ****  * handled and are mapped to while (1) */
 110:../cyfxtx.c   **** 
 111:../cyfxtx.c   **** /* This function is the undefined instruction handler. This
 112:../cyfxtx.c   ****  * occurs when the CPU encounters an undefined instruction. */
 113:../cyfxtx.c   **** void
 114:../cyfxtx.c   **** CyU3PUndefinedHandler (
 115:../cyfxtx.c   ****         void)
 116:../cyfxtx.c   **** {
  42              		.loc 1 116 0
  43              		.cfi_startproc
  44              		@ args = 0, pretend = 0, frame = 0
  45              		@ frame_needed = 1, uses_anonymous_args = 0
  46              		@ link register save eliminated.
  47 0000 04B02DE5 		str	fp, [sp, #-4]!
  48              	.LCFI0:
  49              		.cfi_def_cfa_offset 4
  50 0004 00B08DE2 		add	fp, sp, #0
  51              		.cfi_offset 11, -4
  52              	.LCFI1:
  53              		.cfi_def_cfa_register 11
  54              	.L2:
 117:../cyfxtx.c   ****     for (;;);
  55              		.loc 1 117 0 discriminator 1
  56 0008 FEFFFFEA 		b	.L2
  57              		.cfi_endproc
  58              	.LFE0:
  60              		.align	2
  61              		.global	CyU3PPrefetchHandler
  63              	CyU3PPrefetchHandler:
  64              	.LFB1:
 118:../cyfxtx.c   **** }
 119:../cyfxtx.c   **** 
 120:../cyfxtx.c   **** /* This function is the intruction prefetch error handler. This
 121:../cyfxtx.c   ****  * occurs when the CPU encounters an instruction prefetch error.
 122:../cyfxtx.c   ****  * Since there are no virtual memory use case, this is an unknown
 123:../cyfxtx.c   ****  * memory access error. This is a fatal error. */
 124:../cyfxtx.c   **** void
 125:../cyfxtx.c   **** CyU3PPrefetchHandler (
 126:../cyfxtx.c   ****         void)
 127:../cyfxtx.c   **** {
  65              		.loc 1 127 0
  66              		.cfi_startproc
  67              		@ args = 0, pretend = 0, frame = 0
  68              		@ frame_needed = 1, uses_anonymous_args = 0
  69              		@ link register save eliminated.
  70 000c 04B02DE5 		str	fp, [sp, #-4]!
  71              	.LCFI2:
  72              		.cfi_def_cfa_offset 4
  73 0010 00B08DE2 		add	fp, sp, #0
  74              		.cfi_offset 11, -4
  75              	.LCFI3:
  76              		.cfi_def_cfa_register 11
  77              	.L4:
 128:../cyfxtx.c   ****     for (;;);
  78              		.loc 1 128 0 discriminator 1
  79 0014 FEFFFFEA 		b	.L4
  80              		.cfi_endproc
  81              	.LFE1:
  83              		.align	2
  84              		.global	CyU3PAbortHandler
  86              	CyU3PAbortHandler:
  87              	.LFB2:
 129:../cyfxtx.c   **** }
 130:../cyfxtx.c   **** 
 131:../cyfxtx.c   **** /* This function is the data abort error handler. This occurs when
 132:../cyfxtx.c   ****  * the CPU encounters an data prefetch error. Since there are no
 133:../cyfxtx.c   ****  * virtual memory use case, this is an unknown memory access error.
 134:../cyfxtx.c   ****  * This is a fatal error. */
 135:../cyfxtx.c   **** void
 136:../cyfxtx.c   **** CyU3PAbortHandler (
 137:../cyfxtx.c   ****         void)
 138:../cyfxtx.c   **** {
  88              		.loc 1 138 0
  89              		.cfi_startproc
  90              		@ args = 0, pretend = 0, frame = 0
  91              		@ frame_needed = 1, uses_anonymous_args = 0
  92              		@ link register save eliminated.
  93 0018 04B02DE5 		str	fp, [sp, #-4]!
  94              	.LCFI4:
  95              		.cfi_def_cfa_offset 4
  96 001c 00B08DE2 		add	fp, sp, #0
  97              		.cfi_offset 11, -4
  98              	.LCFI5:
  99              		.cfi_def_cfa_register 11
 100              	.L6:
 139:../cyfxtx.c   ****     for (;;);
 101              		.loc 1 139 0 discriminator 1
 102 0020 FEFFFFEA 		b	.L6
 103              		.cfi_endproc
 104              	.LFE2:
 106              		.align	2
 107              		.global	tx_application_define
 109              	tx_application_define:
 110              	.LFB3:
 140:../cyfxtx.c   **** }
 141:../cyfxtx.c   **** 
 142:../cyfxtx.c   **** /* This function is expected to be invoked by the RTOS kernel after
 143:../cyfxtx.c   ****  * initialization. No explicit call to this function must be made.
 144:../cyfxtx.c   ****  */
 145:../cyfxtx.c   **** void
 146:../cyfxtx.c   **** tx_application_define (
 147:../cyfxtx.c   ****         void *unusedMem)
 148:../cyfxtx.c   **** {
 111              		.loc 1 148 0
 112              		.cfi_startproc
 113              		@ args = 0, pretend = 0, frame = 8
 114              		@ frame_needed = 1, uses_anonymous_args = 0
 115 0024 00482DE9 		stmfd	sp!, {fp, lr}
 116              	.LCFI6:
 117              		.cfi_def_cfa_offset 8
 118 0028 04B08DE2 		add	fp, sp, #4
 119              		.cfi_offset 14, -4
 120              		.cfi_offset 11, -8
 121              	.LCFI7:
 122              		.cfi_def_cfa 11, 4
 123 002c 08D04DE2 		sub	sp, sp, #8
 124 0030 08000BE5 		str	r0, [fp, #-8]
 149:../cyfxtx.c   ****     (void) unusedMem;
 150:../cyfxtx.c   ****     CyU3PApplicationDefine ();
 125              		.loc 1 150 0
 126 0034 FEFFFFEB 		bl	CyU3PApplicationDefine
 151:../cyfxtx.c   **** }
 127              		.loc 1 151 0
 128 0038 04D04BE2 		sub	sp, fp, #4
 129 003c 0088BDE8 		ldmfd	sp!, {fp, pc}
 130              		.cfi_endproc
 131              	.LFE3:
 133              		.align	2
 134              		.global	CyU3PMemInit
 136              	CyU3PMemInit:
 137              	.LFB4:
 152:../cyfxtx.c   **** 
 153:../cyfxtx.c   **** /* This function initializes the custom heap for OS specific dynamic memory allocation.
 154:../cyfxtx.c   ****  * The function should not be explicitly invoked. This function is called from the 
 155:../cyfxtx.c   ****  * API library. Modify this function depending upon the heap requirement of 
 156:../cyfxtx.c   ****  * application code. The minimum required value is specified by the predefined macro.
 157:../cyfxtx.c   ****  * Any value less than specified can cause the drivers to stop functioning.
 158:../cyfxtx.c   ****  * The function creates a global byte pool.
 159:../cyfxtx.c   ****  */
 160:../cyfxtx.c   **** void
 161:../cyfxtx.c   **** CyU3PMemInit (
 162:../cyfxtx.c   ****         void)
 163:../cyfxtx.c   **** {
 138              		.loc 1 163 0
 139              		.cfi_startproc
 140              		@ args = 0, pretend = 0, frame = 0
 141              		@ frame_needed = 1, uses_anonymous_args = 0
 142 0040 00482DE9 		stmfd	sp!, {fp, lr}
 143              	.LCFI8:
 144              		.cfi_def_cfa_offset 8
 145 0044 04B08DE2 		add	fp, sp, #4
 146              		.cfi_offset 14, -4
 147              		.cfi_offset 11, -8
 148              	.LCFI9:
 149              		.cfi_def_cfa 11, 4
 150 0048 08D04DE2 		sub	sp, sp, #8
 164:../cyfxtx.c   ****     if (!glMemPoolInit)
 151              		.loc 1 164 0
 152 004c 38309FE5 		ldr	r3, .L10
 153 0050 003093E5 		ldr	r3, [r3, #0]
 154 0054 000053E3 		cmp	r3, #0
 155 0058 0900001A 		bne	.L8
 165:../cyfxtx.c   ****     {
 166:../cyfxtx.c   **** 	glMemPoolInit = CyTrue;
 156              		.loc 1 166 0
 157 005c 28309FE5 		ldr	r3, .L10
 158 0060 0120A0E3 		mov	r2, #1
 159 0064 002083E5 		str	r2, [r3, #0]
 167:../cyfxtx.c   **** 	CyU3PBytePoolCreate (&glMemBytePool, CY_U3P_MEM_HEAP_BASE, CY_U3P_MEM_HEAP_SIZE);
 160              		.loc 1 167 0
 161 0068 3430A0E3 		mov	r3, #52
 162 006c 00308DE5 		str	r3, [sp, #0]
 163 0070 18009FE5 		ldr	r0, .L10+4
 164 0074 0010A0E3 		mov	r1, #0
 165 0078 14209FE5 		ldr	r2, .L10+8
 166 007c 0239A0E3 		mov	r3, #32768
 167 0080 FEFFFFEB 		bl	_txe_byte_pool_create
 168              	.L8:
 168:../cyfxtx.c   ****     }
 169:../cyfxtx.c   **** }
 169              		.loc 1 169 0
 170 0084 04D04BE2 		sub	sp, fp, #4
 171 0088 0088BDE8 		ldmfd	sp!, {fp, pc}
 172              	.L11:
 173              		.align	2
 174              	.L10:
 175 008c 00000000 		.word	glMemPoolInit
 176 0090 00000000 		.word	glMemBytePool
 177 0094 00800340 		.word	1073971200
 178              		.cfi_endproc
 179              	.LFE4:
 181              		.align	2
 182              		.global	CyU3PMemAlloc
 184              	CyU3PMemAlloc:
 185              	.LFB5:
 170:../cyfxtx.c   **** 
 171:../cyfxtx.c   **** void *
 172:../cyfxtx.c   **** CyU3PMemAlloc (
 173:../cyfxtx.c   ****         uint32_t size)
 174:../cyfxtx.c   **** {
 186              		.loc 1 174 0
 187              		.cfi_startproc
 188              		@ args = 0, pretend = 0, frame = 16
 189              		@ frame_needed = 1, uses_anonymous_args = 0
 190 0098 00482DE9 		stmfd	sp!, {fp, lr}
 191              	.LCFI10:
 192              		.cfi_def_cfa_offset 8
 193 009c 04B08DE2 		add	fp, sp, #4
 194              		.cfi_offset 14, -4
 195              		.cfi_offset 11, -8
 196              	.LCFI11:
 197              		.cfi_def_cfa 11, 4
 198 00a0 10D04DE2 		sub	sp, sp, #16
 199 00a4 10000BE5 		str	r0, [fp, #-16]
 175:../cyfxtx.c   ****     void     *ret_p;
 176:../cyfxtx.c   ****     uint32_t status;
 177:../cyfxtx.c   **** 
 178:../cyfxtx.c   ****     /* Cannot wait in interrupt context */
 179:../cyfxtx.c   ****     if (CyU3PThreadIdentify ())
 200              		.loc 1 179 0
 201 00a8 FEFFFFEB 		bl	_tx_thread_identify
 202 00ac 0030A0E1 		mov	r3, r0
 203 00b0 000053E3 		cmp	r3, #0
 204 00b4 0700000A 		beq	.L13
 180:../cyfxtx.c   ****     {
 181:../cyfxtx.c   ****         status = CyU3PByteAlloc (&glMemBytePool, (void **)&ret_p, size, CY_U3P_MEM_ALLOC_TIMEOUT);
 205              		.loc 1 181 0
 206 00b8 0C304BE2 		sub	r3, fp, #12
 207 00bc 54009FE5 		ldr	r0, .L17
 208 00c0 0310A0E1 		mov	r1, r3
 209 00c4 10201BE5 		ldr	r2, [fp, #-16]
 210 00c8 0A30A0E3 		mov	r3, #10
 211 00cc FEFFFFEB 		bl	_txe_byte_allocate
 212 00d0 08000BE5 		str	r0, [fp, #-8]
 213 00d4 060000EA 		b	.L14
 214              	.L13:
 182:../cyfxtx.c   ****     }
 183:../cyfxtx.c   ****     else
 184:../cyfxtx.c   ****     {
 185:../cyfxtx.c   ****         status = CyU3PByteAlloc (&glMemBytePool, (void **)&ret_p, size, CYU3P_NO_WAIT);
 215              		.loc 1 185 0
 216 00d8 0C304BE2 		sub	r3, fp, #12
 217 00dc 34009FE5 		ldr	r0, .L17
 218 00e0 0310A0E1 		mov	r1, r3
 219 00e4 10201BE5 		ldr	r2, [fp, #-16]
 220 00e8 0030A0E3 		mov	r3, #0
 221 00ec FEFFFFEB 		bl	_txe_byte_allocate
 222 00f0 08000BE5 		str	r0, [fp, #-8]
 223              	.L14:
 186:../cyfxtx.c   ****     }
 187:../cyfxtx.c   **** 
 188:../cyfxtx.c   ****     if(status == CY_U3P_SUCCESS)
 224              		.loc 1 188 0
 225 00f4 08301BE5 		ldr	r3, [fp, #-8]
 226 00f8 000053E3 		cmp	r3, #0
 227 00fc 0100001A 		bne	.L15
 189:../cyfxtx.c   ****     {
 190:../cyfxtx.c   ****         return ret_p;
 228              		.loc 1 190 0
 229 0100 0C301BE5 		ldr	r3, [fp, #-12]
 230 0104 000000EA 		b	.L16
 231              	.L15:
 191:../cyfxtx.c   ****     }
 192:../cyfxtx.c   **** 
 193:../cyfxtx.c   ****     return (NULL);
 232              		.loc 1 193 0
 233 0108 0030A0E3 		mov	r3, #0
 234              	.L16:
 194:../cyfxtx.c   **** }
 235              		.loc 1 194 0
 236 010c 0300A0E1 		mov	r0, r3
 237 0110 04D04BE2 		sub	sp, fp, #4
 238 0114 0088BDE8 		ldmfd	sp!, {fp, pc}
 239              	.L18:
 240              		.align	2
 241              	.L17:
 242 0118 00000000 		.word	glMemBytePool
 243              		.cfi_endproc
 244              	.LFE5:
 246              		.align	2
 247              		.global	CyU3PMemFree
 249              	CyU3PMemFree:
 250              	.LFB6:
 195:../cyfxtx.c   **** 
 196:../cyfxtx.c   **** void
 197:../cyfxtx.c   **** CyU3PMemFree (
 198:../cyfxtx.c   ****         void *mem_p)
 199:../cyfxtx.c   **** {
 251              		.loc 1 199 0
 252              		.cfi_startproc
 253              		@ args = 0, pretend = 0, frame = 8
 254              		@ frame_needed = 1, uses_anonymous_args = 0
 255 011c 00482DE9 		stmfd	sp!, {fp, lr}
 256              	.LCFI12:
 257              		.cfi_def_cfa_offset 8
 258 0120 04B08DE2 		add	fp, sp, #4
 259              		.cfi_offset 14, -4
 260              		.cfi_offset 11, -8
 261              	.LCFI13:
 262              		.cfi_def_cfa 11, 4
 263 0124 08D04DE2 		sub	sp, sp, #8
 264 0128 08000BE5 		str	r0, [fp, #-8]
 200:../cyfxtx.c   ****     CyU3PByteFree (mem_p);
 265              		.loc 1 200 0
 266 012c 08001BE5 		ldr	r0, [fp, #-8]
 267 0130 FEFFFFEB 		bl	_txe_byte_release
 201:../cyfxtx.c   **** }
 268              		.loc 1 201 0
 269 0134 04D04BE2 		sub	sp, fp, #4
 270 0138 0088BDE8 		ldmfd	sp!, {fp, pc}
 271              		.cfi_endproc
 272              	.LFE6:
 274              		.align	2
 275              		.global	CyU3PMemSet
 277              	CyU3PMemSet:
 278              	.LFB7:
 202:../cyfxtx.c   **** 
 203:../cyfxtx.c   **** void
 204:../cyfxtx.c   **** CyU3PMemSet (
 205:../cyfxtx.c   ****         uint8_t *ptr,
 206:../cyfxtx.c   ****         uint8_t data,
 207:../cyfxtx.c   ****         uint32_t count)
 208:../cyfxtx.c   **** {
 279              		.loc 1 208 0
 280              		.cfi_startproc
 281              		@ args = 0, pretend = 0, frame = 16
 282              		@ frame_needed = 1, uses_anonymous_args = 0
 283              		@ link register save eliminated.
 284 013c 04B02DE5 		str	fp, [sp, #-4]!
 285              	.LCFI14:
 286              		.cfi_def_cfa_offset 4
 287 0140 00B08DE2 		add	fp, sp, #0
 288              		.cfi_offset 11, -4
 289              	.LCFI15:
 290              		.cfi_def_cfa_register 11
 291 0144 14D04DE2 		sub	sp, sp, #20
 292 0148 08000BE5 		str	r0, [fp, #-8]
 293 014c 0130A0E1 		mov	r3, r1
 294 0150 10200BE5 		str	r2, [fp, #-16]
 295 0154 09304BE5 		strb	r3, [fp, #-9]
 209:../cyfxtx.c   ****     /* Loop unrolling for faster operation */
 210:../cyfxtx.c   ****     while (count >> 3)
 296              		.loc 1 210 0
 297 0158 240000EA 		b	.L21
 298              	.L22:
 211:../cyfxtx.c   ****     {
 212:../cyfxtx.c   ****         ptr[0] = data;
 299              		.loc 1 212 0
 300 015c 08301BE5 		ldr	r3, [fp, #-8]
 301 0160 09205BE5 		ldrb	r2, [fp, #-9]
 302 0164 0020C3E5 		strb	r2, [r3, #0]
 213:../cyfxtx.c   ****         ptr[1] = data;
 303              		.loc 1 213 0
 304 0168 08301BE5 		ldr	r3, [fp, #-8]
 305 016c 013083E2 		add	r3, r3, #1
 306 0170 09205BE5 		ldrb	r2, [fp, #-9]
 307 0174 0020C3E5 		strb	r2, [r3, #0]
 214:../cyfxtx.c   ****         ptr[2] = data;
 308              		.loc 1 214 0
 309 0178 08301BE5 		ldr	r3, [fp, #-8]
 310 017c 023083E2 		add	r3, r3, #2
 311 0180 09205BE5 		ldrb	r2, [fp, #-9]
 312 0184 0020C3E5 		strb	r2, [r3, #0]
 215:../cyfxtx.c   ****         ptr[3] = data;
 313              		.loc 1 215 0
 314 0188 08301BE5 		ldr	r3, [fp, #-8]
 315 018c 033083E2 		add	r3, r3, #3
 316 0190 09205BE5 		ldrb	r2, [fp, #-9]
 317 0194 0020C3E5 		strb	r2, [r3, #0]
 216:../cyfxtx.c   ****         ptr[4] = data;
 318              		.loc 1 216 0
 319 0198 08301BE5 		ldr	r3, [fp, #-8]
 320 019c 043083E2 		add	r3, r3, #4
 321 01a0 09205BE5 		ldrb	r2, [fp, #-9]
 322 01a4 0020C3E5 		strb	r2, [r3, #0]
 217:../cyfxtx.c   ****         ptr[5] = data;
 323              		.loc 1 217 0
 324 01a8 08301BE5 		ldr	r3, [fp, #-8]
 325 01ac 053083E2 		add	r3, r3, #5
 326 01b0 09205BE5 		ldrb	r2, [fp, #-9]
 327 01b4 0020C3E5 		strb	r2, [r3, #0]
 218:../cyfxtx.c   ****         ptr[6] = data;
 328              		.loc 1 218 0
 329 01b8 08301BE5 		ldr	r3, [fp, #-8]
 330 01bc 063083E2 		add	r3, r3, #6
 331 01c0 09205BE5 		ldrb	r2, [fp, #-9]
 332 01c4 0020C3E5 		strb	r2, [r3, #0]
 219:../cyfxtx.c   ****         ptr[7] = data;
 333              		.loc 1 219 0
 334 01c8 08301BE5 		ldr	r3, [fp, #-8]
 335 01cc 073083E2 		add	r3, r3, #7
 336 01d0 09205BE5 		ldrb	r2, [fp, #-9]
 337 01d4 0020C3E5 		strb	r2, [r3, #0]
 220:../cyfxtx.c   **** 
 221:../cyfxtx.c   ****         count -= 8;
 338              		.loc 1 221 0
 339 01d8 10301BE5 		ldr	r3, [fp, #-16]
 340 01dc 083043E2 		sub	r3, r3, #8
 341 01e0 10300BE5 		str	r3, [fp, #-16]
 222:../cyfxtx.c   ****         ptr += 8;
 342              		.loc 1 222 0
 343 01e4 08301BE5 		ldr	r3, [fp, #-8]
 344 01e8 083083E2 		add	r3, r3, #8
 345 01ec 08300BE5 		str	r3, [fp, #-8]
 346              	.L21:
 210:../cyfxtx.c   ****     while (count >> 3)
 347              		.loc 1 210 0 discriminator 1
 348 01f0 10301BE5 		ldr	r3, [fp, #-16]
 349 01f4 A331A0E1 		mov	r3, r3, lsr #3
 350 01f8 000053E3 		cmp	r3, #0
 351 01fc D6FFFF1A 		bne	.L22
 223:../cyfxtx.c   ****     }
 224:../cyfxtx.c   **** 
 225:../cyfxtx.c   ****     while (count--)
 352              		.loc 1 225 0
 353 0200 050000EA 		b	.L23
 354              	.L24:
 226:../cyfxtx.c   ****     {
 227:../cyfxtx.c   ****         *ptr = data;
 355              		.loc 1 227 0
 356 0204 08301BE5 		ldr	r3, [fp, #-8]
 357 0208 09205BE5 		ldrb	r2, [fp, #-9]
 358 020c 0020C3E5 		strb	r2, [r3, #0]
 228:../cyfxtx.c   ****         ptr++;
 359              		.loc 1 228 0
 360 0210 08301BE5 		ldr	r3, [fp, #-8]
 361 0214 013083E2 		add	r3, r3, #1
 362 0218 08300BE5 		str	r3, [fp, #-8]
 363              	.L23:
 225:../cyfxtx.c   ****     while (count--)
 364              		.loc 1 225 0 discriminator 1
 365 021c 10301BE5 		ldr	r3, [fp, #-16]
 366 0220 000053E3 		cmp	r3, #0
 367 0224 0030A003 		moveq	r3, #0
 368 0228 0130A013 		movne	r3, #1
 369 022c FF3003E2 		and	r3, r3, #255
 370 0230 10201BE5 		ldr	r2, [fp, #-16]
 371 0234 012042E2 		sub	r2, r2, #1
 372 0238 10200BE5 		str	r2, [fp, #-16]
 373 023c 000053E3 		cmp	r3, #0
 374 0240 EFFFFF1A 		bne	.L24
 229:../cyfxtx.c   ****     }
 230:../cyfxtx.c   **** }
 375              		.loc 1 230 0
 376 0244 00D08BE2 		add	sp, fp, #0
 377 0248 04B09DE4 		ldmfd	sp!, {fp}
 378 024c 1EFF2FE1 		bx	lr
 379              		.cfi_endproc
 380              	.LFE7:
 382              		.align	2
 383              		.global	CyU3PMemCopy
 385              	CyU3PMemCopy:
 386              	.LFB8:
 231:../cyfxtx.c   **** 
 232:../cyfxtx.c   **** void
 233:../cyfxtx.c   **** CyU3PMemCopy (
 234:../cyfxtx.c   ****         uint8_t *dest, 
 235:../cyfxtx.c   ****         uint8_t *src,
 236:../cyfxtx.c   ****         uint32_t count)
 237:../cyfxtx.c   **** {
 387              		.loc 1 237 0
 388              		.cfi_startproc
 389              		@ args = 0, pretend = 0, frame = 16
 390              		@ frame_needed = 1, uses_anonymous_args = 0
 391              		@ link register save eliminated.
 392 0250 04B02DE5 		str	fp, [sp, #-4]!
 393              	.LCFI16:
 394              		.cfi_def_cfa_offset 4
 395 0254 00B08DE2 		add	fp, sp, #0
 396              		.cfi_offset 11, -4
 397              	.LCFI17:
 398              		.cfi_def_cfa_register 11
 399 0258 14D04DE2 		sub	sp, sp, #20
 400 025c 08000BE5 		str	r0, [fp, #-8]
 401 0260 0C100BE5 		str	r1, [fp, #-12]
 402 0264 10200BE5 		str	r2, [fp, #-16]
 238:../cyfxtx.c   ****     /* Loop unrolling for faster operation */
 239:../cyfxtx.c   ****     while (count >> 3)
 403              		.loc 1 239 0
 404 0268 360000EA 		b	.L26
 405              	.L27:
 240:../cyfxtx.c   ****     {
 241:../cyfxtx.c   ****         dest[0] = src[0];
 406              		.loc 1 241 0
 407 026c 0C301BE5 		ldr	r3, [fp, #-12]
 408 0270 0020D3E5 		ldrb	r2, [r3, #0]	@ zero_extendqisi2
 409 0274 08301BE5 		ldr	r3, [fp, #-8]
 410 0278 0020C3E5 		strb	r2, [r3, #0]
 242:../cyfxtx.c   ****         dest[1] = src[1];
 411              		.loc 1 242 0
 412 027c 08301BE5 		ldr	r3, [fp, #-8]
 413 0280 013083E2 		add	r3, r3, #1
 414 0284 0C201BE5 		ldr	r2, [fp, #-12]
 415 0288 012082E2 		add	r2, r2, #1
 416 028c 0020D2E5 		ldrb	r2, [r2, #0]	@ zero_extendqisi2
 417 0290 0020C3E5 		strb	r2, [r3, #0]
 243:../cyfxtx.c   ****         dest[2] = src[2];
 418              		.loc 1 243 0
 419 0294 08301BE5 		ldr	r3, [fp, #-8]
 420 0298 023083E2 		add	r3, r3, #2
 421 029c 0C201BE5 		ldr	r2, [fp, #-12]
 422 02a0 022082E2 		add	r2, r2, #2
 423 02a4 0020D2E5 		ldrb	r2, [r2, #0]	@ zero_extendqisi2
 424 02a8 0020C3E5 		strb	r2, [r3, #0]
 244:../cyfxtx.c   ****         dest[3] = src[3];
 425              		.loc 1 244 0
 426 02ac 08301BE5 		ldr	r3, [fp, #-8]
 427 02b0 033083E2 		add	r3, r3, #3
 428 02b4 0C201BE5 		ldr	r2, [fp, #-12]
 429 02b8 032082E2 		add	r2, r2, #3
 430 02bc 0020D2E5 		ldrb	r2, [r2, #0]	@ zero_extendqisi2
 431 02c0 0020C3E5 		strb	r2, [r3, #0]
 245:../cyfxtx.c   ****         dest[4] = src[4];
 432              		.loc 1 245 0
 433 02c4 08301BE5 		ldr	r3, [fp, #-8]
 434 02c8 043083E2 		add	r3, r3, #4
 435 02cc 0C201BE5 		ldr	r2, [fp, #-12]
 436 02d0 042082E2 		add	r2, r2, #4
 437 02d4 0020D2E5 		ldrb	r2, [r2, #0]	@ zero_extendqisi2
 438 02d8 0020C3E5 		strb	r2, [r3, #0]
 246:../cyfxtx.c   ****         dest[5] = src[5];
 439              		.loc 1 246 0
 440 02dc 08301BE5 		ldr	r3, [fp, #-8]
 441 02e0 053083E2 		add	r3, r3, #5
 442 02e4 0C201BE5 		ldr	r2, [fp, #-12]
 443 02e8 052082E2 		add	r2, r2, #5
 444 02ec 0020D2E5 		ldrb	r2, [r2, #0]	@ zero_extendqisi2
 445 02f0 0020C3E5 		strb	r2, [r3, #0]
 247:../cyfxtx.c   ****         dest[6] = src[6];
 446              		.loc 1 247 0
 447 02f4 08301BE5 		ldr	r3, [fp, #-8]
 448 02f8 063083E2 		add	r3, r3, #6
 449 02fc 0C201BE5 		ldr	r2, [fp, #-12]
 450 0300 062082E2 		add	r2, r2, #6
 451 0304 0020D2E5 		ldrb	r2, [r2, #0]	@ zero_extendqisi2
 452 0308 0020C3E5 		strb	r2, [r3, #0]
 248:../cyfxtx.c   ****         dest[7] = src[7];
 453              		.loc 1 248 0
 454 030c 08301BE5 		ldr	r3, [fp, #-8]
 455 0310 073083E2 		add	r3, r3, #7
 456 0314 0C201BE5 		ldr	r2, [fp, #-12]
 457 0318 072082E2 		add	r2, r2, #7
 458 031c 0020D2E5 		ldrb	r2, [r2, #0]	@ zero_extendqisi2
 459 0320 0020C3E5 		strb	r2, [r3, #0]
 249:../cyfxtx.c   **** 
 250:../cyfxtx.c   ****         count -= 8;
 460              		.loc 1 250 0
 461 0324 10301BE5 		ldr	r3, [fp, #-16]
 462 0328 083043E2 		sub	r3, r3, #8
 463 032c 10300BE5 		str	r3, [fp, #-16]
 251:../cyfxtx.c   ****         dest += 8;
 464              		.loc 1 251 0
 465 0330 08301BE5 		ldr	r3, [fp, #-8]
 466 0334 083083E2 		add	r3, r3, #8
 467 0338 08300BE5 		str	r3, [fp, #-8]
 252:../cyfxtx.c   ****         src += 8;
 468              		.loc 1 252 0
 469 033c 0C301BE5 		ldr	r3, [fp, #-12]
 470 0340 083083E2 		add	r3, r3, #8
 471 0344 0C300BE5 		str	r3, [fp, #-12]
 472              	.L26:
 239:../cyfxtx.c   ****     while (count >> 3)
 473              		.loc 1 239 0 discriminator 1
 474 0348 10301BE5 		ldr	r3, [fp, #-16]
 475 034c A331A0E1 		mov	r3, r3, lsr #3
 476 0350 000053E3 		cmp	r3, #0
 477 0354 C4FFFF1A 		bne	.L27
 253:../cyfxtx.c   ****     }
 254:../cyfxtx.c   **** 
 255:../cyfxtx.c   ****     while (count--)
 478              		.loc 1 255 0
 479 0358 090000EA 		b	.L28
 480              	.L29:
 256:../cyfxtx.c   ****     {
 257:../cyfxtx.c   ****         *dest = *src;
 481              		.loc 1 257 0
 482 035c 0C301BE5 		ldr	r3, [fp, #-12]
 483 0360 0020D3E5 		ldrb	r2, [r3, #0]	@ zero_extendqisi2
 484 0364 08301BE5 		ldr	r3, [fp, #-8]
 485 0368 0020C3E5 		strb	r2, [r3, #0]
 258:../cyfxtx.c   ****         dest++;
 486              		.loc 1 258 0
 487 036c 08301BE5 		ldr	r3, [fp, #-8]
 488 0370 013083E2 		add	r3, r3, #1
 489 0374 08300BE5 		str	r3, [fp, #-8]
 259:../cyfxtx.c   ****         src++;
 490              		.loc 1 259 0
 491 0378 0C301BE5 		ldr	r3, [fp, #-12]
 492 037c 013083E2 		add	r3, r3, #1
 493 0380 0C300BE5 		str	r3, [fp, #-12]
 494              	.L28:
 255:../cyfxtx.c   ****     while (count--)
 495              		.loc 1 255 0 discriminator 1
 496 0384 10301BE5 		ldr	r3, [fp, #-16]
 497 0388 000053E3 		cmp	r3, #0
 498 038c 0030A003 		moveq	r3, #0
 499 0390 0130A013 		movne	r3, #1
 500 0394 FF3003E2 		and	r3, r3, #255
 501 0398 10201BE5 		ldr	r2, [fp, #-16]
 502 039c 012042E2 		sub	r2, r2, #1
 503 03a0 10200BE5 		str	r2, [fp, #-16]
 504 03a4 000053E3 		cmp	r3, #0
 505 03a8 EBFFFF1A 		bne	.L29
 260:../cyfxtx.c   ****     }
 261:../cyfxtx.c   **** }
 506              		.loc 1 261 0
 507 03ac 00D08BE2 		add	sp, fp, #0
 508 03b0 04B09DE4 		ldmfd	sp!, {fp}
 509 03b4 1EFF2FE1 		bx	lr
 510              		.cfi_endproc
 511              	.LFE8:
 513              		.align	2
 514              		.global	CyU3PMemCmp
 516              	CyU3PMemCmp:
 517              	.LFB9:
 262:../cyfxtx.c   **** 
 263:../cyfxtx.c   **** int32_t 
 264:../cyfxtx.c   **** CyU3PMemCmp (
 265:../cyfxtx.c   ****         const void* s1,
 266:../cyfxtx.c   ****         const void* s2, 
 267:../cyfxtx.c   ****         uint32_t n)
 268:../cyfxtx.c   **** {
 518              		.loc 1 268 0
 519              		.cfi_startproc
 520              		@ args = 0, pretend = 0, frame = 24
 521              		@ frame_needed = 1, uses_anonymous_args = 0
 522              		@ link register save eliminated.
 523 03b8 04B02DE5 		str	fp, [sp, #-4]!
 524              	.LCFI18:
 525              		.cfi_def_cfa_offset 4
 526 03bc 00B08DE2 		add	fp, sp, #0
 527              		.cfi_offset 11, -4
 528              	.LCFI19:
 529              		.cfi_def_cfa_register 11
 530 03c0 1CD04DE2 		sub	sp, sp, #28
 531 03c4 10000BE5 		str	r0, [fp, #-16]
 532 03c8 14100BE5 		str	r1, [fp, #-20]
 533 03cc 18200BE5 		str	r2, [fp, #-24]
 269:../cyfxtx.c   ****     const uint8_t *ptr1 = s1, *ptr2 = s2;
 534              		.loc 1 269 0
 535 03d0 10301BE5 		ldr	r3, [fp, #-16]
 536 03d4 08300BE5 		str	r3, [fp, #-8]
 537 03d8 14301BE5 		ldr	r3, [fp, #-20]
 538 03dc 0C300BE5 		str	r3, [fp, #-12]
 270:../cyfxtx.c   **** 
 271:../cyfxtx.c   ****     while(n--)
 539              		.loc 1 271 0
 540 03e0 120000EA 		b	.L31
 541              	.L34:
 272:../cyfxtx.c   ****     {
 273:../cyfxtx.c   ****         if(*ptr1 != *ptr2)
 542              		.loc 1 273 0
 543 03e4 08301BE5 		ldr	r3, [fp, #-8]
 544 03e8 0020D3E5 		ldrb	r2, [r3, #0]	@ zero_extendqisi2
 545 03ec 0C301BE5 		ldr	r3, [fp, #-12]
 546 03f0 0030D3E5 		ldrb	r3, [r3, #0]	@ zero_extendqisi2
 547 03f4 030052E1 		cmp	r2, r3
 548 03f8 0600000A 		beq	.L32
 274:../cyfxtx.c   ****         {
 275:../cyfxtx.c   ****             return *ptr1 - *ptr2;
 549              		.loc 1 275 0
 550 03fc 08301BE5 		ldr	r3, [fp, #-8]
 551 0400 0030D3E5 		ldrb	r3, [r3, #0]	@ zero_extendqisi2
 552 0404 0320A0E1 		mov	r2, r3
 553 0408 0C301BE5 		ldr	r3, [fp, #-12]
 554 040c 0030D3E5 		ldrb	r3, [r3, #0]	@ zero_extendqisi2
 555 0410 023063E0 		rsb	r3, r3, r2
 556 0414 100000EA 		b	.L33
 557              	.L32:
 276:../cyfxtx.c   ****         }
 277:../cyfxtx.c   ****         
 278:../cyfxtx.c   ****         ptr1++;
 558              		.loc 1 278 0
 559 0418 08301BE5 		ldr	r3, [fp, #-8]
 560 041c 013083E2 		add	r3, r3, #1
 561 0420 08300BE5 		str	r3, [fp, #-8]
 279:../cyfxtx.c   ****         ptr2++;
 562              		.loc 1 279 0
 563 0424 0C301BE5 		ldr	r3, [fp, #-12]
 564 0428 013083E2 		add	r3, r3, #1
 565 042c 0C300BE5 		str	r3, [fp, #-12]
 566              	.L31:
 271:../cyfxtx.c   ****     while(n--)
 567              		.loc 1 271 0 discriminator 1
 568 0430 18301BE5 		ldr	r3, [fp, #-24]
 569 0434 000053E3 		cmp	r3, #0
 570 0438 0030A003 		moveq	r3, #0
 571 043c 0130A013 		movne	r3, #1
 572 0440 FF3003E2 		and	r3, r3, #255
 573 0444 18201BE5 		ldr	r2, [fp, #-24]
 574 0448 012042E2 		sub	r2, r2, #1
 575 044c 18200BE5 		str	r2, [fp, #-24]
 576 0450 000053E3 		cmp	r3, #0
 577 0454 E2FFFF1A 		bne	.L34
 280:../cyfxtx.c   ****     }  
 281:../cyfxtx.c   ****     return 0;
 578              		.loc 1 281 0
 579 0458 0030A0E3 		mov	r3, #0
 580              	.L33:
 282:../cyfxtx.c   **** }
 581              		.loc 1 282 0
 582 045c 0300A0E1 		mov	r0, r3
 583 0460 00D08BE2 		add	sp, fp, #0
 584 0464 04B09DE4 		ldmfd	sp!, {fp}
 585 0468 1EFF2FE1 		bx	lr
 586              		.cfi_endproc
 587              	.LFE9:
 589              		.align	2
 590              		.global	CyU3PDmaBufferInit
 592              	CyU3PDmaBufferInit:
 593              	.LFB10:
 283:../cyfxtx.c   **** 
 284:../cyfxtx.c   **** /* This function shall be invoked by the API library 
 285:../cyfxtx.c   ****  * and should not be explicitly invoked.
 286:../cyfxtx.c   ****  * If other buffer sizes are required by the application code, this function must
 287:../cyfxtx.c   ****  * be modified to create other block pools.
 288:../cyfxtx.c   ****  */
 289:../cyfxtx.c   **** void
 290:../cyfxtx.c   **** CyU3PDmaBufferInit (
 291:../cyfxtx.c   ****         void)
 292:../cyfxtx.c   **** {
 594              		.loc 1 292 0
 595              		.cfi_startproc
 596              		@ args = 0, pretend = 0, frame = 8
 597              		@ frame_needed = 1, uses_anonymous_args = 0
 598 046c 00482DE9 		stmfd	sp!, {fp, lr}
 599              	.LCFI20:
 600              		.cfi_def_cfa_offset 8
 601 0470 04B08DE2 		add	fp, sp, #4
 602              		.cfi_offset 14, -4
 603              		.cfi_offset 11, -8
 604              	.LCFI21:
 605              		.cfi_def_cfa 11, 4
 606 0474 08D04DE2 		sub	sp, sp, #8
 293:../cyfxtx.c   ****     uint32_t status, size;
 294:../cyfxtx.c   ****     uint32_t tmp;
 295:../cyfxtx.c   **** 
 296:../cyfxtx.c   ****     /* If buffer manager has already been initialized, just return. */
 297:../cyfxtx.c   ****     if ((glBufferManager.startAddr != 0) && (glBufferManager.regionSize != 0))
 607              		.loc 1 297 0
 608 0478 EC309FE5 		ldr	r3, .L42
 609 047c 383093E5 		ldr	r3, [r3, #56]
 610 0480 000053E3 		cmp	r3, #0
 611 0484 0300000A 		beq	.L36
 612              		.loc 1 297 0 is_stmt 0 discriminator 1
 613 0488 DC309FE5 		ldr	r3, .L42
 614 048c 3C3093E5 		ldr	r3, [r3, #60]
 615 0490 000053E3 		cmp	r3, #0
 616 0494 2F00001A 		bne	.L40
 617              	.L36:
 298:../cyfxtx.c   ****     {
 299:../cyfxtx.c   ****         return;
 300:../cyfxtx.c   ****     }
 301:../cyfxtx.c   **** 
 302:../cyfxtx.c   ****     /* Create a mutex variable for safe allocation. */
 303:../cyfxtx.c   ****     status = CyU3PMutexCreate (&glBufferManager.lock, CYU3P_NO_INHERIT);
 618              		.loc 1 303 0 is_stmt 1
 619 0498 CC009FE5 		ldr	r0, .L42
 620 049c 0010A0E3 		mov	r1, #0
 621 04a0 0020A0E3 		mov	r2, #0
 622 04a4 3830A0E3 		mov	r3, #56
 623 04a8 FEFFFFEB 		bl	_txe_mutex_create
 624 04ac 08000BE5 		str	r0, [fp, #-8]
 304:../cyfxtx.c   ****     if (status != CY_U3P_SUCCESS)
 625              		.loc 1 304 0
 626 04b0 08301BE5 		ldr	r3, [fp, #-8]
 627 04b4 000053E3 		cmp	r3, #0
 628 04b8 2800001A 		bne	.L41
 629              	.L38:
 305:../cyfxtx.c   ****     {
 306:../cyfxtx.c   ****         return;
 307:../cyfxtx.c   ****     }
 308:../cyfxtx.c   **** 
 309:../cyfxtx.c   ****     /* No threads are running at this point in time. There is no need to
 310:../cyfxtx.c   ****        get the mutex. */
 311:../cyfxtx.c   **** 
 312:../cyfxtx.c   ****     /* Allocate the memory buffer to be used to track memory status.
 313:../cyfxtx.c   ****        We need one bit per 32 bytes of memory buffer space. Since a 32
 314:../cyfxtx.c   ****        bit array is being used, round up to the necessary number of
 315:../cyfxtx.c   ****        32 bit words. */
 316:../cyfxtx.c   ****     size = ((CY_U3P_BUFFER_HEAP_SIZE / 32) + 31) / 32;
 630              		.loc 1 316 0
 631 04bc E030A0E3 		mov	r3, #224
 632 04c0 0C300BE5 		str	r3, [fp, #-12]
 317:../cyfxtx.c   ****     glBufferManager.usedStatus = (uint32_t *)CyU3PMemAlloc (size * 4);
 633              		.loc 1 317 0
 634 04c4 0C301BE5 		ldr	r3, [fp, #-12]
 635 04c8 0331A0E1 		mov	r3, r3, asl #2
 636 04cc 0300A0E1 		mov	r0, r3
 637 04d0 FEFFFFEB 		bl	CyU3PMemAlloc
 638 04d4 0030A0E1 		mov	r3, r0
 639 04d8 0320A0E1 		mov	r2, r3
 640 04dc 88309FE5 		ldr	r3, .L42
 641 04e0 402083E5 		str	r2, [r3, #64]
 318:../cyfxtx.c   ****     if (glBufferManager.usedStatus == 0)
 642              		.loc 1 318 0
 643 04e4 80309FE5 		ldr	r3, .L42
 644 04e8 403093E5 		ldr	r3, [r3, #64]
 645 04ec 000053E3 		cmp	r3, #0
 646 04f0 0200001A 		bne	.L39
 319:../cyfxtx.c   ****     {
 320:../cyfxtx.c   ****         CyU3PMutexDestroy (&glBufferManager.lock);
 647              		.loc 1 320 0
 648 04f4 70009FE5 		ldr	r0, .L42
 649 04f8 FEFFFFEB 		bl	_txe_mutex_delete
 321:../cyfxtx.c   ****         return;
 650              		.loc 1 321 0
 651 04fc 180000EA 		b	.L35
 652              	.L39:
 322:../cyfxtx.c   ****     }
 323:../cyfxtx.c   **** 
 324:../cyfxtx.c   ****     /* Initially mark all memory as available. If there are any status bits
 325:../cyfxtx.c   ****        beyond the valid memory range, mark these as unavailable. */
 326:../cyfxtx.c   ****     CyU3PMemSet ((uint8_t *)glBufferManager.usedStatus, 0, (size * 4));
 653              		.loc 1 326 0
 654 0500 64309FE5 		ldr	r3, .L42
 655 0504 403093E5 		ldr	r3, [r3, #64]
 656 0508 0320A0E1 		mov	r2, r3
 657 050c 0C301BE5 		ldr	r3, [fp, #-12]
 658 0510 0331A0E1 		mov	r3, r3, asl #2
 659 0514 0200A0E1 		mov	r0, r2
 660 0518 0010A0E3 		mov	r1, #0
 661 051c 0320A0E1 		mov	r2, r3
 662 0520 FEFFFFEB 		bl	CyU3PMemSet
 327:../cyfxtx.c   ****     if ((CY_U3P_BUFFER_HEAP_SIZE / 32) & 31)
 328:../cyfxtx.c   ****     {
 329:../cyfxtx.c   ****         tmp = 32 - ((CY_U3P_BUFFER_HEAP_SIZE / 32) & 31);
 330:../cyfxtx.c   ****         glBufferManager.usedStatus[size - 1] = ~((1 << tmp) - 1);
 331:../cyfxtx.c   ****     }
 332:../cyfxtx.c   **** 
 333:../cyfxtx.c   ****     /* Initialize the start address and region size variables. */
 334:../cyfxtx.c   ****     glBufferManager.startAddr  = CY_U3P_BUFFER_HEAP_BASE;
 663              		.loc 1 334 0
 664 0524 40309FE5 		ldr	r3, .L42
 665 0528 40209FE5 		ldr	r2, .L42+4
 666 052c 382083E5 		str	r2, [r3, #56]
 335:../cyfxtx.c   ****     glBufferManager.regionSize = CY_U3P_BUFFER_HEAP_SIZE;
 667              		.loc 1 335 0
 668 0530 34309FE5 		ldr	r3, .L42
 669 0534 0E29A0E3 		mov	r2, #229376
 670 0538 3C2083E5 		str	r2, [r3, #60]
 336:../cyfxtx.c   ****     glBufferManager.statusSize = size;
 671              		.loc 1 336 0
 672 053c 28309FE5 		ldr	r3, .L42
 673 0540 0C201BE5 		ldr	r2, [fp, #-12]
 674 0544 442083E5 		str	r2, [r3, #68]
 337:../cyfxtx.c   ****     glBufferManager.searchPos  = 0;
 675              		.loc 1 337 0
 676 0548 1C309FE5 		ldr	r3, .L42
 677 054c 0020A0E3 		mov	r2, #0
 678 0550 482083E5 		str	r2, [r3, #72]
 679 0554 020000EA 		b	.L35
 680              	.L40:
 299:../cyfxtx.c   ****         return;
 681              		.loc 1 299 0
 682 0558 0000A0E1 		mov	r0, r0	@ nop
 683 055c 000000EA 		b	.L35
 684              	.L41:
 306:../cyfxtx.c   ****         return;
 685              		.loc 1 306 0
 686 0560 0000A0E1 		mov	r0, r0	@ nop
 687              	.L35:
 338:../cyfxtx.c   **** }
 688              		.loc 1 338 0
 689 0564 04D04BE2 		sub	sp, fp, #4
 690 0568 0088BDE8 		ldmfd	sp!, {fp, pc}
 691              	.L43:
 692              		.align	2
 693              	.L42:
 694 056c 00000000 		.word	glBufferManager
 695 0570 00000440 		.word	1074003968
 696              		.cfi_endproc
 697              	.LFE10:
 699              		.align	2
 700              		.global	CyU3PDmaBufferDeInit
 702              	CyU3PDmaBufferDeInit:
 703              	.LFB11:
 339:../cyfxtx.c   **** 
 340:../cyfxtx.c   **** /* This function shall be invoked by the API library 
 341:../cyfxtx.c   ****  * and should not be explicitly invoked.
 342:../cyfxtx.c   ****  */
 343:../cyfxtx.c   **** void
 344:../cyfxtx.c   **** CyU3PDmaBufferDeInit (
 345:../cyfxtx.c   ****         void)
 346:../cyfxtx.c   **** {
 704              		.loc 1 346 0
 705              		.cfi_startproc
 706              		@ args = 0, pretend = 0, frame = 8
 707              		@ frame_needed = 1, uses_anonymous_args = 0
 708 0574 00482DE9 		stmfd	sp!, {fp, lr}
 709              	.LCFI22:
 710              		.cfi_def_cfa_offset 8
 711 0578 04B08DE2 		add	fp, sp, #4
 712              		.cfi_offset 14, -4
 713              		.cfi_offset 11, -8
 714              	.LCFI23:
 715              		.cfi_def_cfa 11, 4
 716 057c 08D04DE2 		sub	sp, sp, #8
 347:../cyfxtx.c   ****     uint32_t status;
 348:../cyfxtx.c   **** 
 349:../cyfxtx.c   ****     /* Get the mutex lock. */
 350:../cyfxtx.c   ****     if (CyU3PThreadIdentify ())
 717              		.loc 1 350 0
 718 0580 FEFFFFEB 		bl	_tx_thread_identify
 719 0584 0030A0E1 		mov	r3, r0
 720 0588 000053E3 		cmp	r3, #0
 721 058c 0400000A 		beq	.L45
 351:../cyfxtx.c   ****     {
 352:../cyfxtx.c   ****         status = CyU3PMutexGet (&glBufferManager.lock, CYU3P_WAIT_FOREVER);
 722              		.loc 1 352 0
 723 0590 88009FE5 		ldr	r0, .L50
 724 0594 0010E0E3 		mvn	r1, #0
 725 0598 FEFFFFEB 		bl	_txe_mutex_get
 726 059c 08000BE5 		str	r0, [fp, #-8]
 727 05a0 030000EA 		b	.L46
 728              	.L45:
 353:../cyfxtx.c   ****     }
 354:../cyfxtx.c   ****     else
 355:../cyfxtx.c   ****     {
 356:../cyfxtx.c   ****         status = CyU3PMutexGet (&glBufferManager.lock, CYU3P_NO_WAIT);
 729              		.loc 1 356 0
 730 05a4 74009FE5 		ldr	r0, .L50
 731 05a8 0010A0E3 		mov	r1, #0
 732 05ac FEFFFFEB 		bl	_txe_mutex_get
 733 05b0 08000BE5 		str	r0, [fp, #-8]
 734              	.L46:
 357:../cyfxtx.c   ****     }
 358:../cyfxtx.c   **** 
 359:../cyfxtx.c   ****     if (status != CY_U3P_SUCCESS)
 735              		.loc 1 359 0
 736 05b4 08301BE5 		ldr	r3, [fp, #-8]
 737 05b8 000053E3 		cmp	r3, #0
 738 05bc 1400001A 		bne	.L49
 739              	.L47:
 360:../cyfxtx.c   ****     {
 361:../cyfxtx.c   ****         return;
 362:../cyfxtx.c   ****     }
 363:../cyfxtx.c   **** 
 364:../cyfxtx.c   ****     /* Free memory and zero out variables. */
 365:../cyfxtx.c   ****     CyU3PMemFree (glBufferManager.usedStatus);
 740              		.loc 1 365 0
 741 05c0 58309FE5 		ldr	r3, .L50
 742 05c4 403093E5 		ldr	r3, [r3, #64]
 743 05c8 0300A0E1 		mov	r0, r3
 744 05cc FEFFFFEB 		bl	CyU3PMemFree
 366:../cyfxtx.c   ****     glBufferManager.usedStatus = 0;
 745              		.loc 1 366 0
 746 05d0 48309FE5 		ldr	r3, .L50
 747 05d4 0020A0E3 		mov	r2, #0
 748 05d8 402083E5 		str	r2, [r3, #64]
 367:../cyfxtx.c   ****     glBufferManager.startAddr  = 0;
 749              		.loc 1 367 0
 750 05dc 3C309FE5 		ldr	r3, .L50
 751 05e0 0020A0E3 		mov	r2, #0
 752 05e4 382083E5 		str	r2, [r3, #56]
 368:../cyfxtx.c   ****     glBufferManager.regionSize = 0;
 753              		.loc 1 368 0
 754 05e8 30309FE5 		ldr	r3, .L50
 755 05ec 0020A0E3 		mov	r2, #0
 756 05f0 3C2083E5 		str	r2, [r3, #60]
 369:../cyfxtx.c   ****     glBufferManager.statusSize = 0;
 757              		.loc 1 369 0
 758 05f4 24309FE5 		ldr	r3, .L50
 759 05f8 0020A0E3 		mov	r2, #0
 760 05fc 442083E5 		str	r2, [r3, #68]
 370:../cyfxtx.c   **** 
 371:../cyfxtx.c   ****     /* Free up and destroy the mutex variable. */
 372:../cyfxtx.c   ****     CyU3PMutexPut (&glBufferManager.lock);
 761              		.loc 1 372 0
 762 0600 18009FE5 		ldr	r0, .L50
 763 0604 FEFFFFEB 		bl	_txe_mutex_put
 373:../cyfxtx.c   ****     CyU3PMutexDestroy (&glBufferManager.lock);
 764              		.loc 1 373 0
 765 0608 10009FE5 		ldr	r0, .L50
 766 060c FEFFFFEB 		bl	_txe_mutex_delete
 767 0610 000000EA 		b	.L44
 768              	.L49:
 361:../cyfxtx.c   ****         return;
 769              		.loc 1 361 0
 770 0614 0000A0E1 		mov	r0, r0	@ nop
 771              	.L44:
 374:../cyfxtx.c   **** }
 772              		.loc 1 374 0
 773 0618 04D04BE2 		sub	sp, fp, #4
 774 061c 0088BDE8 		ldmfd	sp!, {fp, pc}
 775              	.L51:
 776              		.align	2
 777              	.L50:
 778 0620 00000000 		.word	glBufferManager
 779              		.cfi_endproc
 780              	.LFE11:
 782              		.align	2
 784              	CyU3PDmaBufMgrSetStatus:
 785              	.LFB12:
 375:../cyfxtx.c   **** 
 376:../cyfxtx.c   **** /* Helper function for the DMA buffer manager. Used to set/clear
 377:../cyfxtx.c   ****    a set of status bits from the alloc/free functions. */
 378:../cyfxtx.c   **** static void
 379:../cyfxtx.c   **** CyU3PDmaBufMgrSetStatus (
 380:../cyfxtx.c   ****         uint32_t startPos,
 381:../cyfxtx.c   ****         uint32_t numBits,
 382:../cyfxtx.c   ****         CyBool_t value)
 383:../cyfxtx.c   **** {
 786              		.loc 1 383 0
 787              		.cfi_startproc
 788              		@ args = 0, pretend = 0, frame = 32
 789              		@ frame_needed = 1, uses_anonymous_args = 0
 790              		@ link register save eliminated.
 791 0624 04B02DE5 		str	fp, [sp, #-4]!
 792              	.LCFI24:
 793              		.cfi_def_cfa_offset 4
 794 0628 00B08DE2 		add	fp, sp, #0
 795              		.cfi_offset 11, -4
 796              	.LCFI25:
 797              		.cfi_def_cfa_register 11
 798 062c 24D04DE2 		sub	sp, sp, #36
 799 0630 18000BE5 		str	r0, [fp, #-24]
 800 0634 1C100BE5 		str	r1, [fp, #-28]
 801 0638 20200BE5 		str	r2, [fp, #-32]
 384:../cyfxtx.c   ****     uint32_t wordnum  = (startPos >> 5);
 802              		.loc 1 384 0
 803 063c 18301BE5 		ldr	r3, [fp, #-24]
 804 0640 A332A0E1 		mov	r3, r3, lsr #5
 805 0644 08300BE5 		str	r3, [fp, #-8]
 385:../cyfxtx.c   ****     uint32_t startbit, endbit, mask;
 386:../cyfxtx.c   **** 
 387:../cyfxtx.c   ****     startbit = (startPos & 31);
 806              		.loc 1 387 0
 807 0648 18301BE5 		ldr	r3, [fp, #-24]
 808 064c 1F3003E2 		and	r3, r3, #31
 809 0650 0C300BE5 		str	r3, [fp, #-12]
 388:../cyfxtx.c   ****     endbit   = CY_U3P_MIN (32, startbit + numBits);
 810              		.loc 1 388 0
 811 0654 0C201BE5 		ldr	r2, [fp, #-12]
 812 0658 1C301BE5 		ldr	r3, [fp, #-28]
 813 065c 033082E0 		add	r3, r2, r3
 814 0660 200053E3 		cmp	r3, #32
 815 0664 2030A023 		movcs	r3, #32
 816 0668 10300BE5 		str	r3, [fp, #-16]
 389:../cyfxtx.c   **** 
 390:../cyfxtx.c   ****     /* Compute a mask that has a 1 at all bit positions to be altered. */
 391:../cyfxtx.c   ****     mask  = (endbit == 32) ? 0xFFFFFFFFU : ((uint32_t)(1 << endbit) - 1);
 817              		.loc 1 391 0
 818 066c 10301BE5 		ldr	r3, [fp, #-16]
 819 0670 200053E3 		cmp	r3, #32
 820 0674 0400000A 		beq	.L53
 821              		.loc 1 391 0 is_stmt 0 discriminator 1
 822 0678 10301BE5 		ldr	r3, [fp, #-16]
 823 067c 0120A0E3 		mov	r2, #1
 824 0680 1233A0E1 		mov	r3, r2, asl r3
 825 0684 013043E2 		sub	r3, r3, #1
 826 0688 000000EA 		b	.L54
 827              	.L53:
 828              		.loc 1 391 0 discriminator 2
 829 068c 0030E0E3 		mvn	r3, #0
 830              	.L54:
 831              		.loc 1 391 0 discriminator 3
 832 0690 14300BE5 		str	r3, [fp, #-20]
 392:../cyfxtx.c   ****     mask -= ((1 << startbit) - 1);
 833              		.loc 1 392 0 is_stmt 1 discriminator 3
 834 0694 0C301BE5 		ldr	r3, [fp, #-12]
 835 0698 0120A0E3 		mov	r2, #1
 836 069c 1233A0E1 		mov	r3, r2, asl r3
 837 06a0 14201BE5 		ldr	r2, [fp, #-20]
 838 06a4 023063E0 		rsb	r3, r3, r2
 839 06a8 013083E2 		add	r3, r3, #1
 840 06ac 14300BE5 		str	r3, [fp, #-20]
 393:../cyfxtx.c   **** 
 394:../cyfxtx.c   ****     /* Repeatedly go through the array and update each 32 bit word as required. */
 395:../cyfxtx.c   ****     while (numBits)
 841              		.loc 1 395 0 discriminator 3
 842 06b0 3C0000EA 		b	.L55
 843              	.L59:
 396:../cyfxtx.c   ****     {
 397:../cyfxtx.c   ****         if (value)
 844              		.loc 1 397 0
 845 06b4 20301BE5 		ldr	r3, [fp, #-32]
 846 06b8 000053E3 		cmp	r3, #0
 847 06bc 0E00000A 		beq	.L56
 398:../cyfxtx.c   ****         {
 399:../cyfxtx.c   ****             glBufferManager.usedStatus[wordnum] |= mask;
 848              		.loc 1 399 0
 849 06c0 F8309FE5 		ldr	r3, .L60
 850 06c4 402093E5 		ldr	r2, [r3, #64]
 851 06c8 08301BE5 		ldr	r3, [fp, #-8]
 852 06cc 0331A0E1 		mov	r3, r3, asl #2
 853 06d0 033082E0 		add	r3, r2, r3
 854 06d4 E4209FE5 		ldr	r2, .L60
 855 06d8 401092E5 		ldr	r1, [r2, #64]
 856 06dc 08201BE5 		ldr	r2, [fp, #-8]
 857 06e0 0221A0E1 		mov	r2, r2, asl #2
 858 06e4 022081E0 		add	r2, r1, r2
 859 06e8 001092E5 		ldr	r1, [r2, #0]
 860 06ec 14201BE5 		ldr	r2, [fp, #-20]
 861 06f0 022081E1 		orr	r2, r1, r2
 862 06f4 002083E5 		str	r2, [r3, #0]
 863 06f8 0E0000EA 		b	.L57
 864              	.L56:
 400:../cyfxtx.c   ****         }
 401:../cyfxtx.c   ****         else
 402:../cyfxtx.c   ****         {
 403:../cyfxtx.c   ****             glBufferManager.usedStatus[wordnum] &= ~mask;
 865              		.loc 1 403 0
 866 06fc BC309FE5 		ldr	r3, .L60
 867 0700 402093E5 		ldr	r2, [r3, #64]
 868 0704 08301BE5 		ldr	r3, [fp, #-8]
 869 0708 0331A0E1 		mov	r3, r3, asl #2
 870 070c 033082E0 		add	r3, r2, r3
 871 0710 A8209FE5 		ldr	r2, .L60
 872 0714 401092E5 		ldr	r1, [r2, #64]
 873 0718 08201BE5 		ldr	r2, [fp, #-8]
 874 071c 0221A0E1 		mov	r2, r2, asl #2
 875 0720 022081E0 		add	r2, r1, r2
 876 0724 001092E5 		ldr	r1, [r2, #0]
 877 0728 14201BE5 		ldr	r2, [fp, #-20]
 878 072c 0220E0E1 		mvn	r2, r2
 879 0730 022001E0 		and	r2, r1, r2
 880 0734 002083E5 		str	r2, [r3, #0]
 881              	.L57:
 404:../cyfxtx.c   ****         }
 405:../cyfxtx.c   **** 
 406:../cyfxtx.c   ****         wordnum++;
 882              		.loc 1 406 0
 883 0738 08301BE5 		ldr	r3, [fp, #-8]
 884 073c 013083E2 		add	r3, r3, #1
 885 0740 08300BE5 		str	r3, [fp, #-8]
 407:../cyfxtx.c   ****         numBits -= (endbit - startbit);
 886              		.loc 1 407 0
 887 0744 0C201BE5 		ldr	r2, [fp, #-12]
 888 0748 10301BE5 		ldr	r3, [fp, #-16]
 889 074c 023063E0 		rsb	r3, r3, r2
 890 0750 1C201BE5 		ldr	r2, [fp, #-28]
 891 0754 033082E0 		add	r3, r2, r3
 892 0758 1C300BE5 		str	r3, [fp, #-28]
 408:../cyfxtx.c   ****         if (numBits >= 32)
 893              		.loc 1 408 0
 894 075c 1C301BE5 		ldr	r3, [fp, #-28]
 895 0760 1F0053E3 		cmp	r3, #31
 896 0764 0600009A 		bls	.L58
 409:../cyfxtx.c   ****         {
 410:../cyfxtx.c   ****             startbit = 0;
 897              		.loc 1 410 0
 898 0768 0030A0E3 		mov	r3, #0
 899 076c 0C300BE5 		str	r3, [fp, #-12]
 411:../cyfxtx.c   ****             endbit   = 32;
 900              		.loc 1 411 0
 901 0770 2030A0E3 		mov	r3, #32
 902 0774 10300BE5 		str	r3, [fp, #-16]
 412:../cyfxtx.c   ****             mask     = 0xFFFFFFFFU;
 903              		.loc 1 412 0
 904 0778 0030E0E3 		mvn	r3, #0
 905 077c 14300BE5 		str	r3, [fp, #-20]
 906 0780 080000EA 		b	.L55
 907              	.L58:
 413:../cyfxtx.c   ****         }
 414:../cyfxtx.c   ****         else
 415:../cyfxtx.c   ****         {
 416:../cyfxtx.c   ****             startbit = 0;
 908              		.loc 1 416 0
 909 0784 0030A0E3 		mov	r3, #0
 910 0788 0C300BE5 		str	r3, [fp, #-12]
 417:../cyfxtx.c   ****             endbit   = numBits;
 911              		.loc 1 417 0
 912 078c 1C301BE5 		ldr	r3, [fp, #-28]
 913 0790 10300BE5 		str	r3, [fp, #-16]
 418:../cyfxtx.c   ****             mask     = ((uint32_t)(1 << numBits) - 1);
 914              		.loc 1 418 0
 915 0794 1C301BE5 		ldr	r3, [fp, #-28]
 916 0798 0120A0E3 		mov	r2, #1
 917 079c 1233A0E1 		mov	r3, r2, asl r3
 918 07a0 013043E2 		sub	r3, r3, #1
 919 07a4 14300BE5 		str	r3, [fp, #-20]
 920              	.L55:
 395:../cyfxtx.c   ****     while (numBits)
 921              		.loc 1 395 0 discriminator 1
 922 07a8 1C301BE5 		ldr	r3, [fp, #-28]
 923 07ac 000053E3 		cmp	r3, #0
 924 07b0 BFFFFF1A 		bne	.L59
 419:../cyfxtx.c   ****         }
 420:../cyfxtx.c   ****     }
 421:../cyfxtx.c   **** }
 925              		.loc 1 421 0
 926 07b4 00D08BE2 		add	sp, fp, #0
 927 07b8 04B09DE4 		ldmfd	sp!, {fp}
 928 07bc 1EFF2FE1 		bx	lr
 929              	.L61:
 930              		.align	2
 931              	.L60:
 932 07c0 00000000 		.word	glBufferManager
 933              		.cfi_endproc
 934              	.LFE12:
 936              		.align	2
 937              		.global	CyU3PDmaBufferAlloc
 939              	CyU3PDmaBufferAlloc:
 940              	.LFB13:
 422:../cyfxtx.c   **** 
 423:../cyfxtx.c   **** /* This function shall be invoked from the DMA module for buffer allocation */
 424:../cyfxtx.c   **** void *
 425:../cyfxtx.c   **** CyU3PDmaBufferAlloc (
 426:../cyfxtx.c   ****         uint16_t size)
 427:../cyfxtx.c   **** {
 941              		.loc 1 427 0
 942              		.cfi_startproc
 943              		@ args = 0, pretend = 0, frame = 32
 944              		@ frame_needed = 1, uses_anonymous_args = 0
 945 07c4 00482DE9 		stmfd	sp!, {fp, lr}
 946              	.LCFI26:
 947              		.cfi_def_cfa_offset 8
 948 07c8 04B08DE2 		add	fp, sp, #4
 949              		.cfi_offset 14, -4
 950              		.cfi_offset 11, -8
 951              	.LCFI27:
 952              		.cfi_def_cfa 11, 4
 953 07cc 20D04DE2 		sub	sp, sp, #32
 954 07d0 0030A0E1 		mov	r3, r0
 955 07d4 BE314BE1 		strh	r3, [fp, #-30]	@ movhi
 428:../cyfxtx.c   ****     uint32_t tmp;
 429:../cyfxtx.c   ****     uint32_t wordnum, bitnum;
 430:../cyfxtx.c   ****     uint32_t count, start = 0;
 956              		.loc 1 430 0
 957 07d8 0030A0E3 		mov	r3, #0
 958 07dc 18300BE5 		str	r3, [fp, #-24]
 431:../cyfxtx.c   ****     void *ptr = 0;
 959              		.loc 1 431 0
 960 07e0 0030A0E3 		mov	r3, #0
 961 07e4 1C300BE5 		str	r3, [fp, #-28]
 432:../cyfxtx.c   **** 
 433:../cyfxtx.c   ****     /* Get the lock for the buffer manager. */
 434:../cyfxtx.c   ****     if (CyU3PThreadIdentify ())
 962              		.loc 1 434 0
 963 07e8 FEFFFFEB 		bl	_tx_thread_identify
 964 07ec 0030A0E1 		mov	r3, r0
 965 07f0 000053E3 		cmp	r3, #0
 966 07f4 0400000A 		beq	.L63
 435:../cyfxtx.c   ****     {
 436:../cyfxtx.c   ****         tmp = CyU3PMutexGet (&glBufferManager.lock, CY_U3P_BUFFER_ALLOC_TIMEOUT);
 967              		.loc 1 436 0
 968 07f8 20029FE5 		ldr	r0, .L78
 969 07fc 0A10A0E3 		mov	r1, #10
 970 0800 FEFFFFEB 		bl	_txe_mutex_get
 971 0804 08000BE5 		str	r0, [fp, #-8]
 972 0808 030000EA 		b	.L64
 973              	.L63:
 437:../cyfxtx.c   ****     }
 438:../cyfxtx.c   ****     else
 439:../cyfxtx.c   ****     {
 440:../cyfxtx.c   ****         tmp = CyU3PMutexGet (&glBufferManager.lock, CYU3P_NO_WAIT);
 974              		.loc 1 440 0
 975 080c 0C029FE5 		ldr	r0, .L78
 976 0810 0010A0E3 		mov	r1, #0
 977 0814 FEFFFFEB 		bl	_txe_mutex_get
 978 0818 08000BE5 		str	r0, [fp, #-8]
 979              	.L64:
 441:../cyfxtx.c   ****     }
 442:../cyfxtx.c   **** 
 443:../cyfxtx.c   ****     if (tmp != CY_U3P_SUCCESS)
 980              		.loc 1 443 0
 981 081c 08301BE5 		ldr	r3, [fp, #-8]
 982 0820 000053E3 		cmp	r3, #0
 983 0824 0100000A 		beq	.L65
 444:../cyfxtx.c   ****     {
 445:../cyfxtx.c   ****         return ptr;
 984              		.loc 1 445 0
 985 0828 1C301BE5 		ldr	r3, [fp, #-28]
 986 082c 780000EA 		b	.L66
 987              	.L65:
 446:../cyfxtx.c   ****     }
 447:../cyfxtx.c   **** 
 448:../cyfxtx.c   ****     /* Make sure the buffer manager has been initialized. */
 449:../cyfxtx.c   ****     if ((glBufferManager.startAddr == 0) || (glBufferManager.regionSize == 0))
 988              		.loc 1 449 0
 989 0830 E8319FE5 		ldr	r3, .L78
 990 0834 383093E5 		ldr	r3, [r3, #56]
 991 0838 000053E3 		cmp	r3, #0
 992 083c 0300000A 		beq	.L67
 993              		.loc 1 449 0 is_stmt 0 discriminator 1
 994 0840 D8319FE5 		ldr	r3, .L78
 995 0844 3C3093E5 		ldr	r3, [r3, #60]
 996 0848 000053E3 		cmp	r3, #0
 997 084c 0300001A 		bne	.L68
 998              	.L67:
 450:../cyfxtx.c   ****     {
 451:../cyfxtx.c   ****         CyU3PMutexPut (&glBufferManager.lock);
 999              		.loc 1 451 0 is_stmt 1
 1000 0850 C8019FE5 		ldr	r0, .L78
 1001 0854 FEFFFFEB 		bl	_txe_mutex_put
 452:../cyfxtx.c   ****         return ptr;
 1002              		.loc 1 452 0
 1003 0858 1C301BE5 		ldr	r3, [fp, #-28]
 1004 085c 6C0000EA 		b	.L66
 1005              	.L68:
 453:../cyfxtx.c   ****     }
 454:../cyfxtx.c   **** 
 455:../cyfxtx.c   ****     /* Find the number of 32 byte chunks required. The minimum size that can be handled is
 456:../cyfxtx.c   ****        64 bytes. */
 457:../cyfxtx.c   ****     size = (size <= 32) ? 2 : (size + 31) / 32;
 1006              		.loc 1 457 0
 1007 0860 BE315BE1 		ldrh	r3, [fp, #-30]
 1008 0864 200053E3 		cmp	r3, #32
 1009 0868 0800009A 		bls	.L69
 1010              		.loc 1 457 0 is_stmt 0 discriminator 1
 1011 086c BE315BE1 		ldrh	r3, [fp, #-30]
 1012 0870 1F3083E2 		add	r3, r3, #31
 1013 0874 1F2083E2 		add	r2, r3, #31
 1014 0878 000053E3 		cmp	r3, #0
 1015 087c 0230A0B1 		movlt	r3, r2
 1016 0880 C332A0E1 		mov	r3, r3, asr #5
 1017 0884 0338A0E1 		mov	r3, r3, asl #16
 1018 0888 2338A0E1 		mov	r3, r3, lsr #16
 1019 088c 000000EA 		b	.L70
 1020              	.L69:
 1021              		.loc 1 457 0 discriminator 2
 1022 0890 0230A0E3 		mov	r3, #2
 1023              	.L70:
 1024              		.loc 1 457 0 discriminator 3
 1025 0894 BE314BE1 		strh	r3, [fp, #-30]	@ movhi
 458:../cyfxtx.c   **** 
 459:../cyfxtx.c   ****     /* Search through the status array to find the first block that fits the need. */
 460:../cyfxtx.c   ****     wordnum = glBufferManager.searchPos;
 1026              		.loc 1 460 0 is_stmt 1 discriminator 3
 1027 0898 80319FE5 		ldr	r3, .L78
 1028 089c 483093E5 		ldr	r3, [r3, #72]
 1029 08a0 0C300BE5 		str	r3, [fp, #-12]
 461:../cyfxtx.c   ****     bitnum  = 0;
 1030              		.loc 1 461 0 discriminator 3
 1031 08a4 0030A0E3 		mov	r3, #0
 1032 08a8 10300BE5 		str	r3, [fp, #-16]
 462:../cyfxtx.c   ****     count   = 0;
 1033              		.loc 1 462 0 discriminator 3
 1034 08ac 0030A0E3 		mov	r3, #0
 1035 08b0 14300BE5 		str	r3, [fp, #-20]
 463:../cyfxtx.c   ****     tmp     = 0;
 1036              		.loc 1 463 0 discriminator 3
 1037 08b4 0030A0E3 		mov	r3, #0
 1038 08b8 08300BE5 		str	r3, [fp, #-8]
 464:../cyfxtx.c   **** 
 465:../cyfxtx.c   ****     /* Stop searching once we have checked all of the words. */
 466:../cyfxtx.c   ****     while (tmp < glBufferManager.statusSize)
 1039              		.loc 1 466 0 discriminator 3
 1040 08bc 3A0000EA 		b	.L71
 1041              	.L76:
 467:../cyfxtx.c   ****     {
 468:../cyfxtx.c   ****         if ((glBufferManager.usedStatus[wordnum] & (1 << bitnum)) == 0)
 1042              		.loc 1 468 0
 1043 08c0 58319FE5 		ldr	r3, .L78
 1044 08c4 402093E5 		ldr	r2, [r3, #64]
 1045 08c8 0C301BE5 		ldr	r3, [fp, #-12]
 1046 08cc 0331A0E1 		mov	r3, r3, asl #2
 1047 08d0 033082E0 		add	r3, r2, r3
 1048 08d4 002093E5 		ldr	r2, [r3, #0]
 1049 08d8 10301BE5 		ldr	r3, [fp, #-16]
 1050 08dc 0110A0E3 		mov	r1, #1
 1051 08e0 1133A0E1 		mov	r3, r1, asl r3
 1052 08e4 033002E0 		and	r3, r2, r3
 1053 08e8 000053E3 		cmp	r3, #0
 1054 08ec 1500001A 		bne	.L72
 469:../cyfxtx.c   ****         {
 470:../cyfxtx.c   ****             if (count == 0)
 1055              		.loc 1 470 0
 1056 08f0 14301BE5 		ldr	r3, [fp, #-20]
 1057 08f4 000053E3 		cmp	r3, #0
 1058 08f8 0500001A 		bne	.L73
 471:../cyfxtx.c   ****             {
 472:../cyfxtx.c   ****                 start = (wordnum << 5) + bitnum + 1;
 1059              		.loc 1 472 0
 1060 08fc 0C301BE5 		ldr	r3, [fp, #-12]
 1061 0900 8322A0E1 		mov	r2, r3, asl #5
 1062 0904 10301BE5 		ldr	r3, [fp, #-16]
 1063 0908 033082E0 		add	r3, r2, r3
 1064 090c 013083E2 		add	r3, r3, #1
 1065 0910 18300BE5 		str	r3, [fp, #-24]
 1066              	.L73:
 473:../cyfxtx.c   ****             }
 474:../cyfxtx.c   ****             count++;
 1067              		.loc 1 474 0
 1068 0914 14301BE5 		ldr	r3, [fp, #-20]
 1069 0918 013083E2 		add	r3, r3, #1
 1070 091c 14300BE5 		str	r3, [fp, #-20]
 475:../cyfxtx.c   ****             if (count == (size + 1))
 1071              		.loc 1 475 0
 1072 0920 BE315BE1 		ldrh	r3, [fp, #-30]
 1073 0924 013083E2 		add	r3, r3, #1
 1074 0928 0320A0E1 		mov	r2, r3
 1075 092c 14301BE5 		ldr	r3, [fp, #-20]
 1076 0930 030052E1 		cmp	r2, r3
 1077 0934 0500001A 		bne	.L74
 476:../cyfxtx.c   ****             {
 477:../cyfxtx.c   ****                 /* The last bit corresponding to the allocated memory is left as zero.
 478:../cyfxtx.c   ****                    This allows us to identify the end of the allocated block while freeing
 479:../cyfxtx.c   ****                    the memory. We need to search for one additional zero while allocating
 480:../cyfxtx.c   ****                    to account for this hack. */
 481:../cyfxtx.c   ****                 glBufferManager.searchPos = wordnum;
 1078              		.loc 1 481 0
 1079 0938 E0309FE5 		ldr	r3, .L78
 1080 093c 0C201BE5 		ldr	r2, [fp, #-12]
 1081 0940 482083E5 		str	r2, [r3, #72]
 482:../cyfxtx.c   ****                 break;
 1082              		.loc 1 482 0
 1083 0944 1D0000EA 		b	.L75
 1084              	.L72:
 483:../cyfxtx.c   ****             }
 484:../cyfxtx.c   ****         }
 485:../cyfxtx.c   ****         else
 486:../cyfxtx.c   ****         {
 487:../cyfxtx.c   ****             count = 0;
 1085              		.loc 1 487 0
 1086 0948 0030A0E3 		mov	r3, #0
 1087 094c 14300BE5 		str	r3, [fp, #-20]
 1088              	.L74:
 488:../cyfxtx.c   ****         }
 489:../cyfxtx.c   **** 
 490:../cyfxtx.c   ****         bitnum++;
 1089              		.loc 1 490 0
 1090 0950 10301BE5 		ldr	r3, [fp, #-16]
 1091 0954 013083E2 		add	r3, r3, #1
 1092 0958 10300BE5 		str	r3, [fp, #-16]
 491:../cyfxtx.c   ****         if (bitnum == 32)
 1093              		.loc 1 491 0
 1094 095c 10301BE5 		ldr	r3, [fp, #-16]
 1095 0960 200053E3 		cmp	r3, #32
 1096 0964 1000001A 		bne	.L71
 492:../cyfxtx.c   ****         {
 493:../cyfxtx.c   ****             bitnum = 0;
 1097              		.loc 1 493 0
 1098 0968 0030A0E3 		mov	r3, #0
 1099 096c 10300BE5 		str	r3, [fp, #-16]
 494:../cyfxtx.c   ****             wordnum++;
 1100              		.loc 1 494 0
 1101 0970 0C301BE5 		ldr	r3, [fp, #-12]
 1102 0974 013083E2 		add	r3, r3, #1
 1103 0978 0C300BE5 		str	r3, [fp, #-12]
 495:../cyfxtx.c   ****             tmp++;
 1104              		.loc 1 495 0
 1105 097c 08301BE5 		ldr	r3, [fp, #-8]
 1106 0980 013083E2 		add	r3, r3, #1
 1107 0984 08300BE5 		str	r3, [fp, #-8]
 496:../cyfxtx.c   ****             if (wordnum == glBufferManager.statusSize)
 1108              		.loc 1 496 0
 1109 0988 90309FE5 		ldr	r3, .L78
 1110 098c 442093E5 		ldr	r2, [r3, #68]
 1111 0990 0C301BE5 		ldr	r3, [fp, #-12]
 1112 0994 030052E1 		cmp	r2, r3
 1113 0998 0300001A 		bne	.L71
 497:../cyfxtx.c   ****             {
 498:../cyfxtx.c   ****                 /* Wrap back to the top of the array. */
 499:../cyfxtx.c   ****                 wordnum = 0;
 1114              		.loc 1 499 0
 1115 099c 0030A0E3 		mov	r3, #0
 1116 09a0 0C300BE5 		str	r3, [fp, #-12]
 500:../cyfxtx.c   ****                 count   = 0;
 1117              		.loc 1 500 0
 1118 09a4 0030A0E3 		mov	r3, #0
 1119 09a8 14300BE5 		str	r3, [fp, #-20]
 1120              	.L71:
 466:../cyfxtx.c   ****     while (tmp < glBufferManager.statusSize)
 1121              		.loc 1 466 0 discriminator 1
 1122 09ac 6C309FE5 		ldr	r3, .L78
 1123 09b0 442093E5 		ldr	r2, [r3, #68]
 1124 09b4 08301BE5 		ldr	r3, [fp, #-8]
 1125 09b8 030052E1 		cmp	r2, r3
 1126 09bc BFFFFF8A 		bhi	.L76
 1127              	.L75:
 501:../cyfxtx.c   ****             }
 502:../cyfxtx.c   ****         }
 503:../cyfxtx.c   ****     }
 504:../cyfxtx.c   **** 
 505:../cyfxtx.c   ****     if (count == (size + 1))
 1128              		.loc 1 505 0
 1129 09c0 BE315BE1 		ldrh	r3, [fp, #-30]
 1130 09c4 013083E2 		add	r3, r3, #1
 1131 09c8 0320A0E1 		mov	r2, r3
 1132 09cc 14301BE5 		ldr	r3, [fp, #-20]
 1133 09d0 030052E1 		cmp	r2, r3
 1134 09d4 0B00001A 		bne	.L77
 506:../cyfxtx.c   ****     {
 507:../cyfxtx.c   ****         /* Mark the memory region identified as occupied and return the pointer. */
 508:../cyfxtx.c   ****         CyU3PDmaBufMgrSetStatus (start, size - 1, CyTrue);
 1135              		.loc 1 508 0
 1136 09d8 BE315BE1 		ldrh	r3, [fp, #-30]
 1137 09dc 013043E2 		sub	r3, r3, #1
 1138 09e0 18001BE5 		ldr	r0, [fp, #-24]
 1139 09e4 0310A0E1 		mov	r1, r3
 1140 09e8 0120A0E3 		mov	r2, #1
 1141 09ec 0CFFFFEB 		bl	CyU3PDmaBufMgrSetStatus
 509:../cyfxtx.c   ****         ptr = (void *)(glBufferManager.startAddr + (start << 5));
 1142              		.loc 1 509 0
 1143 09f0 28309FE5 		ldr	r3, .L78
 1144 09f4 382093E5 		ldr	r2, [r3, #56]
 1145 09f8 18301BE5 		ldr	r3, [fp, #-24]
 1146 09fc 8332A0E1 		mov	r3, r3, asl #5
 1147 0a00 033082E0 		add	r3, r2, r3
 1148 0a04 1C300BE5 		str	r3, [fp, #-28]
 1149              	.L77:
 510:../cyfxtx.c   ****     }
 511:../cyfxtx.c   **** 
 512:../cyfxtx.c   ****     CyU3PMutexPut (&glBufferManager.lock);
 1150              		.loc 1 512 0
 1151 0a08 10009FE5 		ldr	r0, .L78
 1152 0a0c FEFFFFEB 		bl	_txe_mutex_put
 513:../cyfxtx.c   ****     return (ptr);
 1153              		.loc 1 513 0
 1154 0a10 1C301BE5 		ldr	r3, [fp, #-28]
 1155              	.L66:
 514:../cyfxtx.c   **** }
 1156              		.loc 1 514 0
 1157 0a14 0300A0E1 		mov	r0, r3
 1158 0a18 04D04BE2 		sub	sp, fp, #4
 1159 0a1c 0088BDE8 		ldmfd	sp!, {fp, pc}
 1160              	.L79:
 1161              		.align	2
 1162              	.L78:
 1163 0a20 00000000 		.word	glBufferManager
 1164              		.cfi_endproc
 1165              	.LFE13:
 1167              		.align	2
 1168              		.global	CyU3PDmaBufferFree
 1170              	CyU3PDmaBufferFree:
 1171              	.LFB14:
 515:../cyfxtx.c   **** 
 516:../cyfxtx.c   **** /* This function shall be invoked from the DMA module for buffer de-allocation */
 517:../cyfxtx.c   **** int
 518:../cyfxtx.c   **** CyU3PDmaBufferFree (
 519:../cyfxtx.c   ****         void *buffer)
 520:../cyfxtx.c   **** {
 1172              		.loc 1 520 0
 1173              		.cfi_startproc
 1174              		@ args = 0, pretend = 0, frame = 32
 1175              		@ frame_needed = 1, uses_anonymous_args = 0
 1176 0a24 00482DE9 		stmfd	sp!, {fp, lr}
 1177              	.LCFI28:
 1178              		.cfi_def_cfa_offset 8
 1179 0a28 04B08DE2 		add	fp, sp, #4
 1180              		.cfi_offset 14, -4
 1181              		.cfi_offset 11, -8
 1182              	.LCFI29:
 1183              		.cfi_def_cfa 11, 4
 1184 0a2c 20D04DE2 		sub	sp, sp, #32
 1185 0a30 20000BE5 		str	r0, [fp, #-32]
 521:../cyfxtx.c   ****     uint32_t status, start, count;
 522:../cyfxtx.c   ****     uint32_t wordnum, bitnum;
 523:../cyfxtx.c   ****     int      retVal = -1;
 1186              		.loc 1 523 0
 1187 0a34 0030E0E3 		mvn	r3, #0
 1188 0a38 18300BE5 		str	r3, [fp, #-24]
 524:../cyfxtx.c   **** 
 525:../cyfxtx.c   ****     /* Get the lock for the buffer manager. */
 526:../cyfxtx.c   ****     if (CyU3PThreadIdentify ())
 1189              		.loc 1 526 0
 1190 0a3c FEFFFFEB 		bl	_tx_thread_identify
 1191 0a40 0030A0E1 		mov	r3, r0
 1192 0a44 000053E3 		cmp	r3, #0
 1193 0a48 0400000A 		beq	.L81
 527:../cyfxtx.c   ****     {
 528:../cyfxtx.c   ****         status = CyU3PMutexGet (&glBufferManager.lock, CY_U3P_BUFFER_ALLOC_TIMEOUT);
 1194              		.loc 1 528 0
 1195 0a4c 60019FE5 		ldr	r0, .L89
 1196 0a50 0A10A0E3 		mov	r1, #10
 1197 0a54 FEFFFFEB 		bl	_txe_mutex_get
 1198 0a58 08000BE5 		str	r0, [fp, #-8]
 1199 0a5c 030000EA 		b	.L82
 1200              	.L81:
 529:../cyfxtx.c   ****     }
 530:../cyfxtx.c   ****     else
 531:../cyfxtx.c   ****     {
 532:../cyfxtx.c   ****         status = CyU3PMutexGet (&glBufferManager.lock, CYU3P_NO_WAIT);
 1201              		.loc 1 532 0
 1202 0a60 4C019FE5 		ldr	r0, .L89
 1203 0a64 0010A0E3 		mov	r1, #0
 1204 0a68 FEFFFFEB 		bl	_txe_mutex_get
 1205 0a6c 08000BE5 		str	r0, [fp, #-8]
 1206              	.L82:
 533:../cyfxtx.c   ****     }
 534:../cyfxtx.c   **** 
 535:../cyfxtx.c   ****     if (status != CY_U3P_SUCCESS)
 1207              		.loc 1 535 0
 1208 0a70 08301BE5 		ldr	r3, [fp, #-8]
 1209 0a74 000053E3 		cmp	r3, #0
 1210 0a78 0100000A 		beq	.L83
 536:../cyfxtx.c   ****     {
 537:../cyfxtx.c   ****         return retVal;
 1211              		.loc 1 537 0
 1212 0a7c 18301BE5 		ldr	r3, [fp, #-24]
 1213 0a80 480000EA 		b	.L84
 1214              	.L83:
 538:../cyfxtx.c   ****     }
 539:../cyfxtx.c   **** 
 540:../cyfxtx.c   ****     /* If the buffer address is within the range specified, count the number of consecutive ones an
 541:../cyfxtx.c   ****        clear them. */
 542:../cyfxtx.c   ****     start = (uint32_t)buffer;
 1215              		.loc 1 542 0
 1216 0a84 20301BE5 		ldr	r3, [fp, #-32]
 1217 0a88 1C300BE5 		str	r3, [fp, #-28]
 543:../cyfxtx.c   ****     if ((start > glBufferManager.startAddr) && (start < (glBufferManager.startAddr + glBufferManage
 1218              		.loc 1 543 0
 1219 0a8c 20319FE5 		ldr	r3, .L89
 1220 0a90 382093E5 		ldr	r2, [r3, #56]
 1221 0a94 1C301BE5 		ldr	r3, [fp, #-28]
 1222 0a98 030052E1 		cmp	r2, r3
 1223 0a9c 3E00002A 		bcs	.L85
 1224              		.loc 1 543 0 is_stmt 0 discriminator 1
 1225 0aa0 0C319FE5 		ldr	r3, .L89
 1226 0aa4 382093E5 		ldr	r2, [r3, #56]
 1227 0aa8 04319FE5 		ldr	r3, .L89
 1228 0aac 3C3093E5 		ldr	r3, [r3, #60]
 1229 0ab0 032082E0 		add	r2, r2, r3
 1230 0ab4 1C301BE5 		ldr	r3, [fp, #-28]
 1231 0ab8 030052E1 		cmp	r2, r3
 1232 0abc 3600009A 		bls	.L85
 544:../cyfxtx.c   ****     {
 545:../cyfxtx.c   ****         start = ((start - glBufferManager.startAddr) >> 5);
 1233              		.loc 1 545 0 is_stmt 1
 1234 0ac0 EC309FE5 		ldr	r3, .L89
 1235 0ac4 383093E5 		ldr	r3, [r3, #56]
 1236 0ac8 1C201BE5 		ldr	r2, [fp, #-28]
 1237 0acc 023063E0 		rsb	r3, r3, r2
 1238 0ad0 A332A0E1 		mov	r3, r3, lsr #5
 1239 0ad4 1C300BE5 		str	r3, [fp, #-28]
 546:../cyfxtx.c   **** 
 547:../cyfxtx.c   ****         wordnum = (start >> 5);
 1240              		.loc 1 547 0
 1241 0ad8 1C301BE5 		ldr	r3, [fp, #-28]
 1242 0adc A332A0E1 		mov	r3, r3, lsr #5
 1243 0ae0 10300BE5 		str	r3, [fp, #-16]
 548:../cyfxtx.c   ****         bitnum  = (start & 0x1F);
 1244              		.loc 1 548 0
 1245 0ae4 1C301BE5 		ldr	r3, [fp, #-28]
 1246 0ae8 1F3003E2 		and	r3, r3, #31
 1247 0aec 14300BE5 		str	r3, [fp, #-20]
 549:../cyfxtx.c   ****         count   = 0;
 1248              		.loc 1 549 0
 1249 0af0 0030A0E3 		mov	r3, #0
 1250 0af4 0C300BE5 		str	r3, [fp, #-12]
 550:../cyfxtx.c   **** 
 551:../cyfxtx.c   ****         while ((wordnum < glBufferManager.statusSize) && ((glBufferManager.usedStatus[wordnum] & (1
 1251              		.loc 1 551 0
 1252 0af8 0D0000EA 		b	.L86
 1253              	.L88:
 552:../cyfxtx.c   ****         {
 553:../cyfxtx.c   ****             count++;
 1254              		.loc 1 553 0
 1255 0afc 0C301BE5 		ldr	r3, [fp, #-12]
 1256 0b00 013083E2 		add	r3, r3, #1
 1257 0b04 0C300BE5 		str	r3, [fp, #-12]
 554:../cyfxtx.c   ****             bitnum++;
 1258              		.loc 1 554 0
 1259 0b08 14301BE5 		ldr	r3, [fp, #-20]
 1260 0b0c 013083E2 		add	r3, r3, #1
 1261 0b10 14300BE5 		str	r3, [fp, #-20]
 555:../cyfxtx.c   ****             if (bitnum == 32)
 1262              		.loc 1 555 0
 1263 0b14 14301BE5 		ldr	r3, [fp, #-20]
 1264 0b18 200053E3 		cmp	r3, #32
 1265 0b1c 0400001A 		bne	.L86
 556:../cyfxtx.c   ****             {
 557:../cyfxtx.c   ****                 bitnum = 0;
 1266              		.loc 1 557 0
 1267 0b20 0030A0E3 		mov	r3, #0
 1268 0b24 14300BE5 		str	r3, [fp, #-20]
 558:../cyfxtx.c   ****                 wordnum++;
 1269              		.loc 1 558 0
 1270 0b28 10301BE5 		ldr	r3, [fp, #-16]
 1271 0b2c 013083E2 		add	r3, r3, #1
 1272 0b30 10300BE5 		str	r3, [fp, #-16]
 1273              	.L86:
 551:../cyfxtx.c   ****         while ((wordnum < glBufferManager.statusSize) && ((glBufferManager.usedStatus[wordnum] & (1
 1274              		.loc 1 551 0 discriminator 1
 1275 0b34 78309FE5 		ldr	r3, .L89
 1276 0b38 442093E5 		ldr	r2, [r3, #68]
 1277 0b3c 10301BE5 		ldr	r3, [fp, #-16]
 1278 0b40 030052E1 		cmp	r2, r3
 1279 0b44 0B00009A 		bls	.L87
 551:../cyfxtx.c   ****         while ((wordnum < glBufferManager.statusSize) && ((glBufferManager.usedStatus[wordnum] & (1
 1280              		.loc 1 551 0 is_stmt 0 discriminator 2
 1281 0b48 64309FE5 		ldr	r3, .L89
 1282 0b4c 402093E5 		ldr	r2, [r3, #64]
 1283 0b50 10301BE5 		ldr	r3, [fp, #-16]
 1284 0b54 0331A0E1 		mov	r3, r3, asl #2
 1285 0b58 033082E0 		add	r3, r2, r3
 1286 0b5c 002093E5 		ldr	r2, [r3, #0]
 1287 0b60 14301BE5 		ldr	r3, [fp, #-20]
 1288 0b64 0110A0E3 		mov	r1, #1
 1289 0b68 1133A0E1 		mov	r3, r1, asl r3
 1290 0b6c 033002E0 		and	r3, r2, r3
 1291 0b70 000053E3 		cmp	r3, #0
 1292 0b74 E0FFFF1A 		bne	.L88
 1293              	.L87:
 559:../cyfxtx.c   ****             }
 560:../cyfxtx.c   ****         }
 561:../cyfxtx.c   **** 
 562:../cyfxtx.c   ****         CyU3PDmaBufMgrSetStatus (start, count, CyFalse);
 1294              		.loc 1 562 0 is_stmt 1
 1295 0b78 1C001BE5 		ldr	r0, [fp, #-28]
 1296 0b7c 0C101BE5 		ldr	r1, [fp, #-12]
 1297 0b80 0020A0E3 		mov	r2, #0
 1298 0b84 A6FEFFEB 		bl	CyU3PDmaBufMgrSetStatus
 563:../cyfxtx.c   **** 
 564:../cyfxtx.c   ****         /* Start the next buffer search at the top of the heap. This can help reduce fragmentation 
 565:../cyfxtx.c   ****            most of the heap is allocated and then freed as a whole. */
 566:../cyfxtx.c   ****         glBufferManager.searchPos = 0;
 1299              		.loc 1 566 0
 1300 0b88 24309FE5 		ldr	r3, .L89
 1301 0b8c 0020A0E3 		mov	r2, #0
 1302 0b90 482083E5 		str	r2, [r3, #72]
 567:../cyfxtx.c   ****         retVal = 0;
 1303              		.loc 1 567 0
 1304 0b94 0030A0E3 		mov	r3, #0
 1305 0b98 18300BE5 		str	r3, [fp, #-24]
 1306              	.L85:
 568:../cyfxtx.c   ****     }
 569:../cyfxtx.c   **** 
 570:../cyfxtx.c   ****     /* Free the lock before we go. */
 571:../cyfxtx.c   ****     CyU3PMutexPut (&glBufferManager.lock);
 1307              		.loc 1 571 0
 1308 0b9c 10009FE5 		ldr	r0, .L89
 1309 0ba0 FEFFFFEB 		bl	_txe_mutex_put
 572:../cyfxtx.c   ****     return retVal;
 1310              		.loc 1 572 0
 1311 0ba4 18301BE5 		ldr	r3, [fp, #-24]
 1312              	.L84:
 573:../cyfxtx.c   **** }
 1313              		.loc 1 573 0
 1314 0ba8 0300A0E1 		mov	r0, r3
 1315 0bac 04D04BE2 		sub	sp, fp, #4
 1316 0bb0 0088BDE8 		ldmfd	sp!, {fp, pc}
 1317              	.L90:
 1318              		.align	2
 1319              	.L89:
 1320 0bb4 00000000 		.word	glBufferManager
 1321              		.cfi_endproc
 1322              	.LFE14:
 1324              		.align	2
 1325              		.global	CyU3PFreeHeaps
 1327              	CyU3PFreeHeaps:
 1328              	.LFB15:
 574:../cyfxtx.c   **** 
 575:../cyfxtx.c   **** void
 576:../cyfxtx.c   **** CyU3PFreeHeaps (
 577:../cyfxtx.c   **** 	void)
 578:../cyfxtx.c   **** {
 1329              		.loc 1 578 0
 1330              		.cfi_startproc
 1331              		@ args = 0, pretend = 0, frame = 0
 1332              		@ frame_needed = 1, uses_anonymous_args = 0
 1333 0bb8 00482DE9 		stmfd	sp!, {fp, lr}
 1334              	.LCFI30:
 1335              		.cfi_def_cfa_offset 8
 1336 0bbc 04B08DE2 		add	fp, sp, #4
 1337              		.cfi_offset 14, -4
 1338              		.cfi_offset 11, -8
 1339              	.LCFI31:
 1340              		.cfi_def_cfa 11, 4
 579:../cyfxtx.c   ****     /* Free up the mem and buffer heaps. */
 580:../cyfxtx.c   ****     CyU3PDmaBufferDeInit ();
 1341              		.loc 1 580 0
 1342 0bc0 FEFFFFEB 		bl	CyU3PDmaBufferDeInit
 581:../cyfxtx.c   ****     CyU3PBytePoolDestroy (&glMemBytePool);
 1343              		.loc 1 581 0
 1344 0bc4 10009FE5 		ldr	r0, .L92
 1345 0bc8 FEFFFFEB 		bl	_txe_byte_pool_delete
 582:../cyfxtx.c   ****     glMemPoolInit = CyFalse;
 1346              		.loc 1 582 0
 1347 0bcc 0C309FE5 		ldr	r3, .L92+4
 1348 0bd0 0020A0E3 		mov	r2, #0
 1349 0bd4 002083E5 		str	r2, [r3, #0]
 583:../cyfxtx.c   **** }
 1350              		.loc 1 583 0
 1351 0bd8 0088BDE8 		ldmfd	sp!, {fp, pc}
 1352              	.L93:
 1353              		.align	2
 1354              	.L92:
 1355 0bdc 00000000 		.word	glMemBytePool
 1356 0be0 00000000 		.word	glMemPoolInit
 1357              		.cfi_endproc
 1358              	.LFE15:
 1360              	.Letext0:
DEFINED SYMBOLS
                            *ABS*:00000000 cyfxtx.c
C:\Users\x\AppData\Local\Temp\ccOUCBZO.s:26     .bss:00000000 glMemPoolInit
C:\Users\x\AppData\Local\Temp\ccOUCBZO.s:23     .bss:00000000 $d
                            *COM*:00000034 glMemBytePool
C:\Users\x\AppData\Local\Temp\ccOUCBZO.s:33     .bss:00000004 glBufferManager
C:\Users\x\AppData\Local\Temp\ccOUCBZO.s:36     .text:00000000 $a
C:\Users\x\AppData\Local\Temp\ccOUCBZO.s:39     .text:00000000 CyU3PUndefinedHandler
C:\Users\x\AppData\Local\Temp\ccOUCBZO.s:63     .text:0000000c CyU3PPrefetchHandler
C:\Users\x\AppData\Local\Temp\ccOUCBZO.s:86     .text:00000018 CyU3PAbortHandler
C:\Users\x\AppData\Local\Temp\ccOUCBZO.s:109    .text:00000024 tx_application_define
C:\Users\x\AppData\Local\Temp\ccOUCBZO.s:136    .text:00000040 CyU3PMemInit
C:\Users\x\AppData\Local\Temp\ccOUCBZO.s:175    .text:0000008c $d
C:\Users\x\AppData\Local\Temp\ccOUCBZO.s:181    .text:00000098 $a
C:\Users\x\AppData\Local\Temp\ccOUCBZO.s:184    .text:00000098 CyU3PMemAlloc
C:\Users\x\AppData\Local\Temp\ccOUCBZO.s:242    .text:00000118 $d
C:\Users\x\AppData\Local\Temp\ccOUCBZO.s:246    .text:0000011c $a
C:\Users\x\AppData\Local\Temp\ccOUCBZO.s:249    .text:0000011c CyU3PMemFree
C:\Users\x\AppData\Local\Temp\ccOUCBZO.s:277    .text:0000013c CyU3PMemSet
C:\Users\x\AppData\Local\Temp\ccOUCBZO.s:385    .text:00000250 CyU3PMemCopy
C:\Users\x\AppData\Local\Temp\ccOUCBZO.s:516    .text:000003b8 CyU3PMemCmp
C:\Users\x\AppData\Local\Temp\ccOUCBZO.s:592    .text:0000046c CyU3PDmaBufferInit
C:\Users\x\AppData\Local\Temp\ccOUCBZO.s:694    .text:0000056c $d
C:\Users\x\AppData\Local\Temp\ccOUCBZO.s:699    .text:00000574 $a
C:\Users\x\AppData\Local\Temp\ccOUCBZO.s:702    .text:00000574 CyU3PDmaBufferDeInit
C:\Users\x\AppData\Local\Temp\ccOUCBZO.s:778    .text:00000620 $d
C:\Users\x\AppData\Local\Temp\ccOUCBZO.s:782    .text:00000624 $a
C:\Users\x\AppData\Local\Temp\ccOUCBZO.s:784    .text:00000624 CyU3PDmaBufMgrSetStatus
C:\Users\x\AppData\Local\Temp\ccOUCBZO.s:932    .text:000007c0 $d
C:\Users\x\AppData\Local\Temp\ccOUCBZO.s:936    .text:000007c4 $a
C:\Users\x\AppData\Local\Temp\ccOUCBZO.s:939    .text:000007c4 CyU3PDmaBufferAlloc
C:\Users\x\AppData\Local\Temp\ccOUCBZO.s:1163   .text:00000a20 $d
C:\Users\x\AppData\Local\Temp\ccOUCBZO.s:1167   .text:00000a24 $a
C:\Users\x\AppData\Local\Temp\ccOUCBZO.s:1170   .text:00000a24 CyU3PDmaBufferFree
C:\Users\x\AppData\Local\Temp\ccOUCBZO.s:1320   .text:00000bb4 $d
C:\Users\x\AppData\Local\Temp\ccOUCBZO.s:1324   .text:00000bb8 $a
C:\Users\x\AppData\Local\Temp\ccOUCBZO.s:1327   .text:00000bb8 CyU3PFreeHeaps
C:\Users\x\AppData\Local\Temp\ccOUCBZO.s:1355   .text:00000bdc $d
                     .debug_frame:00000010 $d

UNDEFINED SYMBOLS
CyU3PApplicationDefine
_txe_byte_pool_create
_tx_thread_identify
_txe_byte_allocate
_txe_byte_release
_txe_mutex_create
_txe_mutex_delete
_txe_mutex_get
_txe_mutex_put
_txe_byte_pool_delete
